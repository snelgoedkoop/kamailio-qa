From a25fd891ae6004e49bfec88bc60ef22a76cb6364 Mon Sep 17 00:00:00 2001
From: karl anderson <karl@2600hz.com>
Date: Thu, 24 Oct 2013 18:50:24 -0400
Subject: [PATCH] do not use contact by default, and fix race-condition resulting in duplicate hash entries and fix consumer leak

---
 modules/db_kazoo/Makefile                          |   32 +
 modules/db_kazoo/blf.c                             | 1532 ++++++++++++++++++++
 modules/db_kazoo/blf.h                             |   25 +
 modules/db_kazoo/db_kazoo.c                        |  208 +++
 modules/db_kazoo/dbase.c                           |  939 ++++++++++++
 modules/db_kazoo/dbase.h                           |  101 ++
 modules/dispatcher/dispatch.c                      |    8 +-
 modules/dispatcher/dispatch.h                      |    1 +
 modules/dispatcher/dispatcher.c                    |   10 +
 modules/presence/bind_presence.c                   |    2 +
 modules/presence/bind_presence.h                   |    3 +
 modules/presence/hash.c                            |    4 +-
 modules/presence/notify.c                          |   94 ++
 modules/presence/notify.h                          |    3 +
 modules/presence/presence.c                        |   20 +-
 modules/presence/presence.h                        |    1 +
 modules/presence/subscribe.c                       |   17 +-
 modules/presence/subscribe.h                       |    4 +-
 modules/presence_dialoginfo/bind_pres_dialoginfo.h |   28 +
 modules/presence_dialoginfo/notify_body.c          |   63 +-
 modules/presence_dialoginfo/notify_body.h          |    7 +
 modules/presence_dialoginfo/presence_dialoginfo.c  |   16 +
 modules/pua/pua.c                                  |    4 +-
 modules/pua_dialoginfo/Makefile                    |    2 +
 modules/pua_dialoginfo/bind_dialoginfo.h           |   29 +
 modules/pua_dialoginfo/dialog_publish.c            |  104 ++-
 modules/pua_dialoginfo/pua_dialoginfo.c            |   78 +-
 modules/pua_dialoginfo/pua_dialoginfo.h            |    7 +
 modules/rls/rls.c                                  |    2 +
 modules/rls/rls.h                                  |    1 +
 modules/rls/subscribe.c                            |    7 +-
 modules/usrloc/dlist.c                             |    3 +-
 modules/usrloc/ul_mod.c                            |    5 +-
 33 files changed, 3290 insertions(+), 70 deletions(-)
 create mode 100644 modules/db_kazoo/Makefile
 create mode 100644 modules/db_kazoo/blf.c
 create mode 100644 modules/db_kazoo/blf.h
 create mode 100644 modules/db_kazoo/db_kazoo.c
 create mode 100644 modules/db_kazoo/dbase.c
 create mode 100644 modules/db_kazoo/dbase.h
 create mode 100644 modules/presence_dialoginfo/bind_pres_dialoginfo.h
 create mode 100644 modules/pua_dialoginfo/bind_dialoginfo.h

diff --git a/modules/db_kazoo/Makefile b/modules/db_kazoo/Makefile
new file mode 100644
index 0000000..668d68c
--- /dev/null
+++ b/modules/db_kazoo/Makefile
@@ -0,0 +1,32 @@
+# $Id$
+#
+# WARNING: do not run this directly, it should be run by the master Makefile
+
+include ../../Makefile.defs
+auto_gen=
+NAME=db_kazoo.so
+
+DEFS+=-I/usr/local/include -DKAMAILIO_MOD_INTERFACE
+LIBS=-L/usr/local/lib -lrabbitmq -ljson
+
+DEFS += -DSER_MOD_INTERFACE
+
+ifeq ($(CROSS_COMPILE),)
+XML2CFG=$(shell which xml2-config)
+endif
+
+ifneq ($(XML2CFG),)
+	DEFS += $(shell $(XML2CFG) --cflags )
+	LIBS += $(shell $(XML2CFG) --libs)
+else
+	DEFS+=-I$(LOCALBASE)/include/libxml2 \
+		-I$(LOCALBASE)/include
+	LIBS+=-L$(LOCALBASE)/lib -lxml2
+endif
+
+
+SERLIBPATH=../../lib
+SER_LIBS=$(SERLIBPATH)/srdb2/srdb2 $(SERLIBPATH)/srdb1/srdb1
+SER_LIBS+=$(SERLIBPATH)/kmi/kmi
+
+include ../../Makefile.modules
diff --git a/modules/db_kazoo/blf.c b/modules/db_kazoo/blf.c
new file mode 100644
index 0000000..9067ed7
--- /dev/null
+++ b/modules/db_kazoo/blf.c
@@ -0,0 +1,1532 @@
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <amqp.h>
+#include <amqp_framing.h>
+#include <amqp_tcp_socket.h>
+#include <json/json.h>
+#include <libxml/parser.h>
+#include "../../parser/parse_to.h"
+#include "../../dprint.h"
+#include "../../mem/mem.h"
+#include "../../timer_proc.h"
+#include "../../sr_module.h"
+#include "../../lib/kmi/mi.h"
+#include "../presence/bind_presence.h"
+#include "../pua_dialoginfo/bind_dialoginfo.h"
+#include "../presence_dialoginfo/bind_pres_dialoginfo.h"
+#include "../../pvar.h"
+#include "blf.h"
+#include "dbase.h"
+
+static presence_api_t presence_api;
+static pua_dialoginfo_api_t pua_dialoginfo_api;
+static pres_dialoginfo_api_t pres_dialoginfo_api;
+
+int rmqp_pres_update_handle(char* req);
+void start_presence_timer_processes(void);
+void start_presence_rmqp_consumer_processes(struct db_id* id);
+void rmqp_consumer_loop(struct db_id* id);
+int dbk_initialize_pres_htable(void);
+
+#define BLF_MAX_DIALOGS 8
+#define BLF_JSON_FROM      	"From" 
+#define BLF_JSON_TO        	"To"
+#define BLF_JSON_CALLID    	"Call-ID"
+#define BLF_JSON_TOTAG     	"To-Tag"
+#define BLF_JSON_FROMTAG   	"From-Tag"
+#define BLF_JSON_STATE     	"State"
+#define BLF_JSON_USER      	"User"
+#define BLF_JSON_FROM     	"From"
+#define BLF_JSON_QUEUE     	"Queue"
+#define BLF_JSON_EXPIRES	"Expires"
+#define BLF_JSON_APP_NAME       "App-Name"
+#define BLF_JSON_APP_VERSION    "App-Version"
+#define BLF_JSON_NODE           "Node"
+#define BLF_JSON_SERVERID       "Server-ID"
+#define BLF_JSON_EVENT_CATEGORY "Event-Category"
+#define BLF_JSON_EVENT_NAME     "Event-Name" 
+#define BLF_JSON_TYPE           "Type"
+#define BLF_JSON_MSG_ID         "Msg-ID"
+#define BLF_JSON_DIRECTION      "Direction"
+
+
+static char blf_queue_name_buffer[128];
+static amqp_bytes_t blf_queue;
+
+str sht_name = str_init("$sht(dbkp=>$ci)");
+pv_spec_t sht_spec;
+char node_name[128];
+
+int dbk_initialize_presence()
+{
+  str unique_string = {0, 0};
+  
+  LM_DBG("dbk_initialize_presence\n");
+  /* bind to presence module */
+  bind_presence_t bind_presence= (bind_presence_t)find_export("bind_presence", 1,0);
+  if (!bind_presence) {
+    LM_ERR("Can't find presence module\n");
+    return -1;
+  }
+  if (bind_presence(&presence_api) < 0) {
+    LM_ERR("Can't bind to presence module api\n");
+    return -1;
+  }
+  /* bind to pua_dialoginfo module */
+  bind_pua_dialoginfo_t bind_pua_dialoginfo= (bind_pua_dialoginfo_t)find_export("bind_pua_dialoginfo", 1,0);
+  if (!bind_pua_dialoginfo) {
+    LM_ERR("Can't find pua_dialoginfo module\n");
+    return -1;
+  }
+  if (bind_pua_dialoginfo(&pua_dialoginfo_api) < 0) {
+    LM_ERR("Can't bind to pua_dialoginfo module api\n");
+    return -1;
+  }
+  
+  /* bind to presence_dialoginfo module */
+  bind_pres_dialoginfo_t bind_pres_dialoginfo= (bind_pres_dialoginfo_t)find_export("bind_pres_dialoginfo", 1,0);
+  if (!bind_pres_dialoginfo) {
+    LM_ERR("Can't find pres_dialoginfo module\n");
+    return -1;
+  }
+
+  if (bind_pres_dialoginfo(&pres_dialoginfo_api) < 0) {
+    LM_ERR("Can't bind to pres_dialoginfo module api\n");
+    return -1;
+  }
+  
+  if ( dbk_initialize_pres_htable() < 0) {
+    LM_ERR("Failed to initialize presence htable\n");
+    return -1;
+  }
+  LM_DBG("Initialized pres_htable\n");
+
+  if ( pv_parse_spec(&sht_name, &sht_spec) == NULL ) {
+    LM_ERR("Failed to parse sht spec\n");
+    return -1;
+  }  
+  
+  tmb.generate_callid(&unique_string);
+  
+  blf_queue.bytes = blf_queue_name_buffer;
+  blf_queue.len = sprintf(blf_queue.bytes, "BLF-%.*s-%.*s",
+                          dbk_node_hostname.len, dbk_node_hostname.s, unique_string.len, unique_string.s);
+ 
+  sprintf(node_name, "kamailio@%.*s", dbk_node_hostname.len, dbk_node_hostname.s);
+  return 0;
+}
+
+
+void dbk_start_presence_rmqp_consumer_processes(struct db_id* id)
+{
+  int i;
+  for (i= 0; i< DBK_PRES_WORKERS_NO; i++) {
+    int newpid = fork_process(PROC_NOCHLDINIT, "RMQP PRESENCE WORKER", 0);
+    if(newpid < 0) {
+      LM_ERR("Failed to start AMQP presence worker\n");
+      return;
+    } else if(newpid == 0) {
+      // child - this will loop forever
+      LM_INFO("Created dbk AMQP presence worker %d\n", newpid);
+      rmqp_consumer_loop(id);
+    } else {
+      LM_INFO("Created dbk AMQP presence worker %d\n", newpid);
+    }	
+  }
+}
+
+void rmqp_consumer_loop(struct db_id* id)
+{
+  amqp_frame_t frame;
+  int result;
+  amqp_basic_deliver_t *d;
+  amqp_basic_properties_t *p;
+  size_t body_target;
+  size_t body_received = 0;
+  char body[2048];
+  rmq_conn_t * rmq;
+  int reconn_retries = 0;
+  
+  rmq = dbk_dummy_db_conn(id);
+  if (rmq == NULL) {
+    LM_ERR("Failed to create AMQP connection\n");
+    return;
+  }
+  
+  while (1) {
+    if (!rmq->conn) {
+      reconn_retries = 0;            
+      while (1) {
+        reconn_retries++;
+        LM_DBG("Attempt %d to connect to AMQP\n", reconn_retries);
+        sleep(1);
+        
+        if (rmqp_open_connection(rmq) < 0) {
+          LM_DBG("Failed to open AMQP connection\n"); 
+          continue;
+        }
+        
+        amqp_queue_declare(rmq->conn, rmq->channel, blf_queue, 0, 0, 0, 1, amqp_empty_table);
+        if (rmq_error("Declaring queue", amqp_get_rpc_reply(rmq->conn))) {
+          LM_DBG("Failed to declare AMQP presence queue\n"); 
+          continue;
+        }
+        LM_DBG("Create presence AMQP queue %.*s\n", (int) blf_queue.len, (char *) blf_queue.bytes);
+        
+        amqp_exchange_declare(rmq->conn, rmq->channel, amqp_cstring_bytes("dialoginfo"), amqp_cstring_bytes("direct"),
+                              0, 0, amqp_empty_table);
+        if (rmq_error("Declaring exchange", amqp_get_rpc_reply(rmq->conn))) {
+          LM_ERR("Failed to declare AMQP dialoginfo exchange\n"); 
+          continue;
+        }
+        
+        static amqp_bytes_t exch = {10, "dialoginfo"};
+        amqp_queue_bind(rmq->conn, rmq->channel, blf_queue, exch, blf_queue, amqp_empty_table);
+        if (rmq_error("Binding queue", amqp_get_rpc_reply(rmq->conn))) {
+          LM_DBG("Unable to bind presence AMQP queue\n"); 
+          continue;
+        }
+        
+        amqp_basic_consume(rmq->conn, rmq->channel, blf_queue, amqp_empty_bytes, 0, 1, 0, amqp_empty_table);
+        if (rmq_error("Consuming", amqp_get_rpc_reply(rmq->conn))) {
+          LM_DBG("Failed to start consuming from queue\n"); 
+          continue;
+        }
+        
+        break;
+      }
+      
+      LM_DBG("Connected to AMQP after %d attempts\n", reconn_retries);
+      
+      continue;
+    }
+    
+    while (1) {
+      LM_DBG("Wait for a packet\n");
+      body_received = 0;
+      amqp_maybe_release_buffers(rmq->conn);                        
+      result = amqp_simple_wait_frame(rmq->conn, &frame);
+      if (result < 0 ) { 
+        LM_ERR("Lost AMQP connection\n");
+        rmq_close(rmq);
+        break;
+      }
+      
+      LM_DBG("Frame type: %d channel: %d\n", frame.frame_type, frame.channel);
+      if (frame.frame_type != AMQP_FRAME_METHOD) {
+        continue;
+      }
+      
+      LM_DBG("Method: %s\n", amqp_method_name(frame.payload.method.id));
+      if (frame.payload.method.id != AMQP_BASIC_DELIVER_METHOD) {
+        continue;
+      }
+      
+      d = (amqp_basic_deliver_t *) frame.payload.method.decoded;
+      LM_DBG("Delivery: %u exchange: %.*s routingkey: %.*s\n",
+             (unsigned) d->delivery_tag,
+             (int) d->exchange.len, (char *) d->exchange.bytes,
+             (int) d->routing_key.len, (char *) d->routing_key.bytes);
+      
+      result = amqp_simple_wait_frame(rmq->conn, &frame);
+      if (result < 0) {
+        LM_ERR("Lost AMQP connection\n");
+        rmq_close(rmq);
+        break;
+      }
+      
+      if (frame.frame_type != AMQP_FRAME_HEADER) {
+        LM_ERR("amqp: Expected header!");
+        break;
+      }
+      
+      p = (amqp_basic_properties_t *) frame.payload.properties.decoded;
+      if (p->_flags & AMQP_BASIC_CONTENT_TYPE_FLAG) {
+        LM_DBG("Content-type: %.*s\n",
+               (int) p->content_type.len, (char *) p->content_type.bytes);
+      }
+      
+      body_target = frame.payload.properties.body_size;
+      
+      while (body_received < body_target) {
+        result = amqp_simple_wait_frame(rmq->conn, &frame);
+        if (result < 0) {
+          LM_ERR("Lost AMQP connection\n");
+          rmq_close(rmq);
+          body_received = 0;
+          break;
+        }
+        
+        if (frame.frame_type != AMQP_FRAME_BODY) {
+          LM_ERR("amqp: Expected header!");
+          body_received = 0;
+          break;
+        }
+        
+        memcpy(body + body_received, frame.payload.body_fragment.bytes,
+               frame.payload.body_fragment.len);
+        
+        body_received += frame.payload.body_fragment.len;
+        
+        LM_INFO("%.*s\n", (int)frame.payload.body_fragment.len,
+                (char*)frame.payload.body_fragment.bytes);
+      }
+      
+      if (body_received != body_target) {
+        LM_CRIT("Unexpected body size: recv %zu, expected %zu\n",
+                body_received, body_target);
+        continue;
+      }
+      
+      /* everything was fine, we can quit now because we received the reply */
+      break;
+    }
+    
+    if (body_received) {
+      body[body_received] = '\0';
+      LM_DBG("Received update %s\n", body);
+      
+      if (rmqp_pres_update_handle(body) < 0) {
+        LM_ERR("Failed to add to the update queue\n");
+      }
+    }
+  }
+  
+  LM_ERR("Presence consumer loop terminated\n");
+  rmq_close(rmq);
+}
+
+typedef struct dbk_pres_dialog {
+  int version;
+  str callid;
+  str localtag;
+  str remotetag;
+  int body_size_alloc;
+  str body;
+  struct dbk_pres_dialog* next;
+} dbk_pres_dialog_t;
+
+typedef struct dbk_pres_user {
+  str user;
+  dbk_pres_dialog_t * pd;
+  struct dbk_pres_user* next;
+} dbk_pres_user_t;
+
+typedef struct {
+  gen_lock_t lock;
+  dbk_pres_user_t* pu;
+}dbk_pres_htable_t;
+
+static dbk_pres_htable_t* dbk_phtable = NULL;
+unsigned int dbk_phtable_size = 256;
+
+int dbk_initialize_pres_htable(void)
+{
+  int i;
+  
+  dbk_phtable = (dbk_pres_htable_t*)shm_malloc(dbk_phtable_size*sizeof(dbk_pres_htable_t));
+  if ( dbk_phtable == NULL ) {
+    LM_ERR("No more shared memory\n");
+    return -1;
+  }
+  memset(dbk_phtable, 0, dbk_phtable_size*sizeof(dbk_pres_htable_t));
+  
+  for ( i = 0; i < dbk_phtable_size; i++ ) {
+    lock_init(&dbk_phtable[i].lock);
+  }	
+  
+  return 0;
+}
+
+void dbk_free_pd(dbk_pres_dialog_t* pd) 
+{
+  shm_free(pd->body.s);
+  shm_free(pd);
+}
+
+void dbk_free_pu(dbk_pres_user_t* pu)
+{
+  dbk_pres_dialog_t *pd_next;
+  dbk_pres_dialog_t *pd = pu->pd;
+  while ( pd ) {
+    pd_next = pd->next;
+    dbk_free_pd(pd);
+    pd = pd_next;
+  }
+  shm_free(pu);
+}
+
+void dbk_destroy_presence(void)
+{
+  dbk_pres_user_t *pu, *pu_next;
+  int i;
+  
+  if ( dbk_phtable == NULL ) {
+    return;
+  }
+  
+  for ( i = 0; i < dbk_phtable_size; i++ ) {
+    lock_destroy(&dbk_phtable[i].lock);
+    pu = dbk_phtable[i].pu;
+    while ( pu ) {
+      pu_next = pu->next;
+      dbk_free_pu(pu);
+      pu = pu_next;
+    }
+    
+  }
+  shm_free(dbk_phtable);
+}
+
+dbk_pres_user_t* dbk_pres_search_pu(unsigned int hash_code, str* user,
+                                    dbk_pres_user_t** pu_prev_ret, dbk_pres_user_t *prev_pu_addr)
+{
+  dbk_pres_user_t *pu, *pu_prev = NULL;
+  
+  for (pu = dbk_phtable[hash_code].pu; pu; pu = pu->next) {
+    if (pu->user.len == user->len &&
+        memcmp(pu->user.s, user->s, user->len)==0) {
+      break;
+    }
+    pu_prev = pu;
+  }
+  if (pu_prev_ret) {
+    *pu_prev_ret = pu_prev;
+  }
+  
+  return pu;
+}
+
+dbk_pres_dialog_t* dbk_new_pres_dialog(str* callid, str* localtag, str* remotetag, str* body) 
+{
+  dbk_pres_dialog_t* pd = (dbk_pres_dialog_t*)shm_malloc(sizeof(dbk_pres_dialog_t) + callid->len+
+                                                         localtag->len + remotetag->len);
+  
+  if ( pd == NULL) {
+    LM_ERR("No more shared memory\n");
+    return NULL;
+  }	
+  memset(pd, 0, sizeof(dbk_pres_dialog_t));
+  char* p = (char*)pd + sizeof(dbk_pres_dialog_t);
+  pd->callid.s = p;
+  memcpy(pd->callid.s, callid->s, callid->len);
+  pd->callid.len = callid->len;
+  p += callid->len;
+  
+  if (localtag->len) {
+    pd->localtag.s = p;
+    memcpy(pd->localtag.s, localtag->s, localtag->len);
+    pd->localtag.len = localtag->len;
+    p += localtag->len;
+  }
+  if (remotetag->len) {
+    pd->remotetag.s = p;
+    memcpy(pd->remotetag.s, remotetag->s, remotetag->len);
+    pd->remotetag.len = remotetag->len;
+    p += remotetag->len;
+  }
+  
+  pd->body_size_alloc = body->len;
+  pd->body.s = (char*)shm_malloc(pd->body_size_alloc);
+  if (pd->body.s == NULL) {
+    LM_ERR("No more shared memory\n");
+    shm_free(pd);
+    return NULL;
+  }
+  memcpy(pd->body.s, body->s, body->len);
+  pd->body.len = body->len;
+  
+  return pd;	
+}
+
+dbk_pres_user_t* dbk_new_pres_user(str* user, str* callid, str* localtag, str* remotetag, str* body) 
+{
+  dbk_pres_user_t* pu = (dbk_pres_user_t*)shm_malloc(sizeof(dbk_pres_user_t) + user->len);
+  
+  if ( pu == NULL) {
+    LM_ERR("No more shared memory\n");
+    return NULL;
+  }	
+  memset(pu, 0, sizeof(dbk_pres_user_t));
+  pu->user.s = (char*)pu + sizeof(dbk_pres_user_t);
+  memcpy(pu->user.s, user->s, user->len);
+  pu->user.len = user->len;
+  pu->pd = dbk_new_pres_dialog(callid, localtag, remotetag, body);
+  if (pu->pd == NULL) {
+    LM_ERR("Failed to construct presence dialog\n");
+    shm_free(pu);
+    return NULL;
+  }
+  return pu;
+}
+
+int dbk_pres_insert_pu(str* local_user, str* callid, str* localtag, str* remotetag, str* body,
+                       unsigned int hash_code) 
+{
+  dbk_pres_user_t* pu = dbk_new_pres_user(local_user, callid, localtag, remotetag, body);
+
+  if (pu == NULL) {
+    LM_ERR("Failed to create new pres user\n");
+    return -1;
+  }
+
+  pu->next = dbk_phtable[hash_code].pu;
+  dbk_phtable[hash_code].pu = pu;
+  return 0;
+}
+
+dbk_pres_dialog_t* dbk_pres_pu_search_pd(dbk_pres_user_t* pu, str* callid, str* localtag,
+                                         str* remotetag, dbk_pres_dialog_t** pd_prev_ret, dbk_pres_dialog_t* prev_pd_addr) 
+{
+  dbk_pres_dialog_t *pd, *pd_prev = NULL;
+  
+  for (pd = pu->pd; pd; pd = pd->next) {
+    if (prev_pd_addr && pd != prev_pd_addr) {
+      pd_prev = pd;
+      continue;
+    }
+    
+    if (pd->callid.len==callid->len && memcmp(pd->callid.s, callid->s, callid->len)==0 &&
+        (!localtag->len || !pd->localtag.len || (localtag->len==pd->localtag.len &&
+                                                 memcmp(localtag->s, pd->localtag.s, localtag->len)==0)) && 
+        (!remotetag->len || !pd->remotetag.len || (remotetag->len==pd->remotetag.len &&
+                                                   memcmp(remotetag->s, pd->remotetag.s, remotetag->len)==0)) ) {
+      break;
+    }
+    
+    pd_prev = pd;
+  }
+  
+  if (pd_prev_ret) *pd_prev_ret = pd_prev;
+  
+  return pd;
+}
+
+
+void dbk_free_xml(str* body) {
+  if (body) {
+    if (body->s)
+      xmlFree(body->s);
+    pkg_free(body);
+  }
+}
+
+int dbk_blf_copy_bodies(dbk_pres_user_t* pu, dbk_pres_dialog_t* curr_pd,
+                        str* dlg_bodies, int* dlg_no) 
+{
+  dbk_pres_dialog_t* pd;
+  int i;
+  
+  for (pd = pu->pd, i= *dlg_no; pd && i< BLF_MAX_DIALOGS; pd = pd->next) {
+    if ( pd == curr_pd) {
+      continue;
+    }
+    dlg_bodies[i].s = (char*) pkg_malloc(pd->body.len);
+    if (dlg_bodies[i].s == NULL) {
+      LM_ERR("No more memory\n");
+      goto error;
+    }
+    memcpy(dlg_bodies[i].s, pd->body.s, pd->body.len);
+    dlg_bodies[i].len = pd->body.len;
+    i++;
+  }
+  if (pd) {
+    LM_WARN("More dialogs than BLF_MAX_DIALOGS=%d for user [%.*s]\n",
+            BLF_MAX_DIALOGS, pu->user.len, pu->user.s);
+  }
+  *dlg_no = i;
+  return 0;
+  
+ error:
+  while(--i>=*dlg_no) {
+    pkg_free(dlg_bodies[i].s);
+  }
+  return -1;
+}
+
+str* dbk_blf_aggregate_body(str* user, str* dlg_bodies, int dlg_no) 
+{
+  str* dlg_bodies_p[BLF_MAX_DIALOGS];
+  struct sip_uri uri;
+  int i;
+  
+  LM_DBG("Aggregate %d bodies\n", dlg_no);
+  
+  if (parse_uri(user->s, user->len, &uri) < 0) {
+    LM_ERR("Failed to parse uri\n");
+    return NULL;
+  }
+  
+  for (i = 0; i < dlg_no; i++) {
+    dlg_bodies_p[i] = &dlg_bodies[i];
+  }
+  
+  return pres_dialoginfo_api.agg_dialoginfo(&uri.user, &uri.host, dlg_bodies_p, dlg_no);
+}
+
+str* dbk_phtable_update(str* local_user, str* remote_user, str* callid,
+                        str* localtag, str* remotetag, str* state, int initiator)
+{
+  dbk_pres_user_t* pu, *pu_prev = NULL;
+  dbk_pres_dialog_t* pd, *pd_prev = NULL;
+  unsigned int hash_code = core_hash(local_user, 0, dbk_phtable_size);
+  str* body = NULL ;
+  int terminated = strcmp(state->s, "terminated")==0?1:0;
+  str dlg_bodies[BLF_MAX_DIALOGS];
+  int dlg_no = 1;
+  int i;
+  
+  LM_DBG("Update dbk phtable: %.*s %.*s %.*s %.*s"
+         ,local_user->len, local_user->s
+         ,remote_user->len, remote_user->s
+         ,callid->len, callid->s
+         ,state->len, state->s);
+  
+  if (terminated) {
+    LM_DBG("Updated to terminated state\n");
+  }
+  
+  lock_get(&dbk_phtable[hash_code].lock);
+  pu = dbk_pres_search_pu(hash_code, local_user, &pu_prev, 0);
+  
+  /**  1. No record for user */
+  if (pu == NULL) {
+    if (!terminated) {		
+      LM_INFO("No record found for %.*s/%.*s, add with initial state %.*s\n"
+              ,local_user->len, local_user->s
+              ,remote_user->len, remote_user->s
+              ,state->len, state->s);
+      if ((body = pua_dialoginfo_api.build_dialoginfo(state->s, local_user, remote_user,
+                                                      callid, initiator, localtag, remotetag, 0 , 0, 0))== NULL) {
+        lock_release(&dbk_phtable[hash_code].lock);
+        LM_ERR("Failed to construct BLF XML doc\n");
+        return NULL;
+      }
+      LM_DBG("dialoginfo body [%.*s]\n", body->len, body->s);
+      if (dbk_pres_insert_pu(local_user, callid, localtag, remotetag, body, hash_code) < 0) {
+        LM_ERR("Failed to insert new pres_user in htable\n");
+      }
+      lock_release(&dbk_phtable[hash_code].lock);
+      return body;
+    }
+    lock_release(&dbk_phtable[hash_code].lock);
+    LM_INFO("No record found for %.*s/%.*s and state terminated, do nothing\n"
+            ,local_user->len, local_user->s
+            ,remote_user->len, remote_user->s);
+    return pua_dialoginfo_api.build_dialoginfo(state->s, local_user, remote_user, callid,
+                                               initiator, localtag, remotetag, 0 , 0, 0);
+  }
+
+  pd = dbk_pres_pu_search_pd(pu, callid, localtag, remotetag, &pd_prev, 0);
+  
+  /**  2. Existing record for user, no record for dialog */
+  if (pd == NULL) {    
+    /* copy the other bodies to create the aggregated body */
+    if (pu->pd != NULL) {
+      dbk_blf_copy_bodies(pu, NULL, dlg_bodies, &dlg_no);
+    }
+    if (!terminated) {
+      LM_INFO("Dialog %.*s not found for %.*s/%.*s, add with initial state %.*s\n"
+              ,callid->len, callid->s
+              ,local_user->len, local_user->s
+              ,remote_user->len, remote_user->s
+              ,state->len, state->s);
+      LM_DBG("Dialog record not found, insert a new one\n");
+      if ((body = pua_dialoginfo_api.build_dialoginfo(state->s, local_user, remote_user,
+                                                      callid, initiator, localtag, remotetag, 0 , 0, 0))== NULL) {
+        lock_release(&dbk_phtable[hash_code].lock);
+        LM_ERR("Failed to construct BLF XML doc\n");
+        goto ret_current_dialog;
+      }
+      LM_DBG("dialoginfo body [%.*s]\n", body->len, body->s);      
+      pd = dbk_new_pres_dialog(callid, localtag, remotetag, body);
+      if (pd == NULL) {
+        lock_release(&dbk_phtable[hash_code].lock);
+        LM_ERR("Failed to create new pres dialog\n");
+        goto ret_agg_dialogs;
+      }
+      pd->next = pu->pd;
+      pu->pd = pd;
+    } else { /* terminated */
+      LM_INFO("Dialog %.*s not found for %.*s/%.*s, building terminated body\n"
+              ,callid->len, callid->s
+              ,local_user->len, local_user->s
+              ,remote_user->len, remote_user->s);
+      body = pua_dialoginfo_api.build_dialoginfo(state->s, local_user, remote_user, callid,
+                                                 initiator, localtag, remotetag, 0 , 0, 0);
+    }
+    lock_release(&dbk_phtable[hash_code].lock);
+    goto ret_agg_dialogs;
+  }
+  
+  /**  3. Existing record for user and existing record for dialog */  
+  /* If there are other dialogs, make a copy of the bodies */
+  if (pu->pd != pd || pd->next != NULL) {
+    dbk_blf_copy_bodies(pu, pd, dlg_bodies, &dlg_no);
+  }
+  if (!terminated) {
+    LM_INFO("Found record %.*s/%.*s and matching dialog %.*s, update the state %.*s\n"
+            ,local_user->len, local_user->s
+            ,remote_user->len, remote_user->s
+            ,callid->len, callid->s
+            ,state->len, state->s);
+    /* update only the body */ 
+    if ((body = pua_dialoginfo_api.build_dialoginfo(state->s, local_user, remote_user,
+                                                    callid, initiator, localtag, remotetag, 0 , 0, 0))== NULL) {
+      lock_release(&dbk_phtable[hash_code].lock);
+      LM_ERR("Failed to construct BLF XML doc\n");
+      goto ret_current_dialog;
+    }
+    LM_DBG("dialoginfo body [%.*s]\n", body->len, body->s);    
+    if (pd->body_size_alloc < body->len) {
+      pd->body_size_alloc = body->len * 2;
+      pd->body.s = (char*) shm_realloc(pd->body.s, pd->body_size_alloc);
+      if (pd->body.s == NULL) {
+        lock_release(&dbk_phtable[hash_code].lock);
+        LM_ERR("No more shared memory\n");
+        goto ret_agg_dialogs;
+      }
+    }
+    memcpy(pd->body.s, body->s, body->len);
+    pd->body.len = body->len;
+    if (pu->pd != pd || pd->next != NULL) {
+      lock_release(&dbk_phtable[hash_code].lock);
+      goto ret_current_dialog;
+    }
+  } else {
+    if (pd_prev == NULL && pd->next == NULL) { // there is no other dialog record
+      LM_INFO("Found record %.*s/%.*s and matching dialog %.*s, no remaining dialogs removing pu record\n"
+              ,local_user->len, local_user->s
+              ,remote_user->len, remote_user->s
+              ,callid->len, callid->s);
+      /* delete pu */
+      if (pu_prev) {
+        pu_prev->next = pu->next;
+      } else {
+        dbk_phtable[hash_code].pu = pu->next;
+      }
+      lock_release(&dbk_phtable[hash_code].lock);
+      dbk_free_pu(pu);
+      body = pua_dialoginfo_api.build_dialoginfo(state->s, local_user, remote_user, callid,
+                                                 initiator, localtag, remotetag, 0 , 0, 0);
+      goto ret_current_dialog;
+    } else {
+      LM_INFO("Found record %.*s/%.*s and matching dialog %.*s, other dialogs remain\n"
+              ,local_user->len, local_user->s
+              ,remote_user->len, remote_user->s
+              ,callid->len, callid->s);
+      /* delete pd */
+      if (pd_prev) {
+        pd_prev->next = pd->next;
+      } else {
+        pu->pd = pd->next;
+      }
+      dbk_free_pd(pd);
+      body = pua_dialoginfo_api.build_dialoginfo(state->s, local_user, remote_user, callid,
+                                                 initiator, localtag, remotetag, 0 , 0, 0);
+    }
+  }
+  lock_release(&dbk_phtable[hash_code].lock);
+
+ ret_agg_dialogs:
+  if (dlg_no > 1) {
+    str* body_copy = body;
+    dlg_bodies[0] = *body;
+    body = dbk_blf_aggregate_body(local_user, dlg_bodies, dlg_no);
+    if (body == NULL) {
+      LM_ERR("Failed to aggregate body\n");
+      body = body_copy;
+    } else {
+      dbk_free_xml(body_copy);
+    }
+  }
+  
+ ret_current_dialog:
+  /* free the copied dialog bodies */
+  for(i =1; i < dlg_no; i++) {
+    pkg_free(dlg_bodies[i].s);
+  }
+  
+  return body;
+}
+
+
+int dbk_pres_update_and_notify(str* local_user, str* remote_user, str* callid,
+                               str* localtag, str* remotetag, str* state, int initiator) {
+  
+  str event = str_init("dialog");
+  str* body;
+  
+  /* update in htable */
+  if ((body = dbk_phtable_update(local_user, remote_user, callid, localtag,
+                                 remotetag, state, initiator)) == 0) { 
+    LM_ERR("Failed to update in htable\n");
+    return -1;
+  }
+  
+  /* call refresh_watchers from presence */
+  if (presence_api.notify_watchers(local_user, &event, body) < 0) {
+    LM_ERR("Failed to notify watchers\n");
+    goto error;
+  }
+  dbk_free_xml(body);
+  return 0;
+ error:
+  dbk_free_xml(body);
+  return -1;
+}
+#define json_extract_field(json_name, field)  do {                      \
+    struct json_object* obj = json_object_object_get(json_obj, json_name); \
+    field.s = (char*)json_object_get_string(obj);                       \
+    if (field.s == NULL) {                                              \
+      LM_DBG("Json-c error - failed to extract field [%s]\n", json_name); \
+      field.s = "";                                                     \
+    } else {                                                            \
+      field.len = strlen(field.s);                                      \
+    }                                                                   \
+    LM_DBG("%s: [%s]\n", json_name, field.s?field.s:"Empty");           \
+  } while (0);
+
+
+int dbk_phtable_flush(int flush_all, str* user)
+{
+  dbk_pres_user_t* pu;
+  
+  if (flush_all) {
+    int i;
+    dbk_pres_user_t* pu_next;
+    for (i = 0; i< dbk_phtable_size; i++) {
+      lock_get(&dbk_phtable[i].lock);
+      pu = dbk_phtable[i].pu;
+      dbk_phtable[i].pu = NULL;
+      lock_release(&dbk_phtable[i].lock);
+      
+      for (; pu; pu = pu_next) {
+        pu_next = pu->next;
+        dbk_free_pu(pu);
+      }
+    }
+  } else {
+    int hash_code;
+    dbk_pres_user_t* pu_prev = NULL;
+    str* body;
+    static str event = str_init("dialog");
+    
+    hash_code = core_hash(user, NULL, dbk_phtable_size);
+    lock_get(&dbk_phtable[hash_code].lock);
+    pu = dbk_pres_search_pu(hash_code, user, &pu_prev, 0);
+    if (pu == NULL) {
+      LM_INFO("FLUSH: No record found for user %.*s\n", user->len, user->s);
+      lock_release(&dbk_phtable[hash_code].lock);
+    } else {
+      LM_INFO("FLUSH: Delete record for user %.*s\n", user->len, user->s);
+      if (pu_prev) { 
+        pu_prev->next = pu->next;
+      } else {
+        dbk_phtable[hash_code].pu = pu->next;
+      }
+      lock_release(&dbk_phtable[hash_code].lock);
+      dbk_free_pu(pu);
+    }
+    
+    
+    /* send a notify with no dialog to clear dialog state */
+    if ( (body = pua_dialoginfo_api.build_dialoginfo(0, user,
+                                                     0, 0, 0, 0, 0, 0, 0, 0)) == NULL ) {
+      LM_ERR("Failed to construct BLF XML doc\n");
+      return -1;
+    }
+    if (presence_api.notify_watchers(user, &event, body) < 0) {
+      LM_ERR("Failed to notify watchers\n");
+      dbk_free_xml(body);
+      return -1;
+    }
+    dbk_free_xml(body);
+  }
+  return 0;
+}
+
+int rmqp_pres_flush_handle(struct json_object* json_obj)
+{
+  str type={0, 0};
+  str user= {0, 0};
+  int flush_all = 0;
+  
+  json_extract_field(BLF_JSON_TYPE, type);
+  if (type.len == 3 && strncmp(type.s, "all", 3) == 0) {
+    flush_all = 1;
+  } else {
+    json_extract_field(BLF_JSON_USER, user);
+  }
+  
+  return dbk_phtable_flush(flush_all, &user);
+}
+
+struct mi_root * mi_dbk_phtable_flush(struct mi_root *cmd, void *param)
+{
+  struct mi_node* node= NULL;
+  str type;
+  str user;
+  int flush_all = 0;
+  
+  node = cmd->node.kids;
+  if(node == NULL) {
+    LM_ERR("Null command- missing parameters\n");
+    return 0;
+  }
+  
+  LM_DBG("Get type\n");
+  
+  /* Get type */
+  type = node->value;
+  if(type.s == NULL || type.len== 0) {
+    LM_ERR( "first parameter empty\n");
+    return init_mi_tree(404, "Missing parameter ('all' or 'user')", 35);
+  }
+  
+  LM_DBG("Flush type=[%.*s]\n", type.len, type.s);
+  
+  if (type.len == 3 && strncmp(type.s, "all", 3) == 0) {
+    LM_INFO("Flush all\n");
+    flush_all = 1;
+  } else {
+    node = node->next;
+    if(node == NULL)
+      return 0;
+    user = node->value;
+    if(user.s == NULL || user.len== 0) {
+      LM_ERR( "No user uri provided\n");
+      return init_mi_tree(404, "No user uri provided", 20);
+    }
+    LM_INFO("Flush user [%.*s]\n", user.len, user.s);
+  }	
+  
+  if (dbk_phtable_flush(flush_all, &user) < 0 ) {
+    LM_ERR("Presence htable flushing failed\n");
+    return init_mi_tree( 500, MI_SSTR(MI_INTERNAL_ERR));
+  }
+  return init_mi_tree( 200, MI_SSTR(MI_OK));
+  
+}
+
+
+
+
+/*
+ * presence update: json format
+ * {"From": "uri", "To": "uri", "State": "state", "Callid": "callid", "From-Tag": "tag", "To-Tag": "tag"}
+ * {"Replaces": "", "Refered-By": ""}
+ * */
+
+int rmqp_pres_update_handle(char* req)
+{
+  str from_user={0, 0}, to_user= {0, 0};
+  str callid= {0, 0}, fromtag= {0, 0}, totag= {0, 0};
+  str state= {0, 0};
+  str event_name={0, 0};
+  str direction={0, 0};
+  struct json_object *json_obj;
+  int ret = 0;
+  
+  /* extract info from json and construct xml */
+  json_obj = json_tokener_parse(req);
+  if (is_error(json_obj)) {
+    LM_ERR("Error parsing json: %s\n", json_tokener_errors[-(unsigned long)json_obj]);
+    LM_ERR("%s\n", req);
+    goto error;
+  }
+  
+  json_extract_field(BLF_JSON_EVENT_NAME, event_name);
+  
+  if ( event_name.len == 5 && strncmp(event_name.s, "flush", 5) == 0 ) {
+    ret = rmqp_pres_flush_handle(json_obj);
+  } else {
+    
+    json_extract_field(BLF_JSON_FROM, from_user);
+    json_extract_field(BLF_JSON_TO, to_user);
+    json_extract_field(BLF_JSON_CALLID, callid);
+    json_extract_field(BLF_JSON_FROMTAG, fromtag);
+    json_extract_field(BLF_JSON_TOTAG, totag);
+    json_extract_field(BLF_JSON_DIRECTION, direction);
+    json_extract_field(BLF_JSON_STATE, state);
+    
+    if ( !from_user.len || !to_user.len || !callid.len || !state.len) {
+      LM_ERR("Wrong formated json %s\n", req);
+      json_object_put(json_obj);
+      goto error;
+    }
+    
+    LM_INFO("Received update: %.*s/%.*s %.*s %.*s"
+            ,from_user.len, from_user.s
+            ,to_user.len, to_user.s
+            ,callid.len, callid.s
+            ,state.len, state.s);
+
+    if (!strcmp(direction.s, "inbound")) {
+      LM_DBG("channel is the initiator\n");
+      ret = dbk_pres_update_and_notify(&from_user, &to_user, &callid, &fromtag, &totag, &state, 1);
+    } else {
+      LM_DBG("channel is the recipient\n");
+      ret = dbk_pres_update_and_notify(&to_user, &from_user, &callid, &totag, &fromtag, &state, 0);
+    }
+    
+    if (ret < 0) {
+      LM_ERR("Failed to process dialoginfo update command\n");
+      ret = -1;
+    }
+    
+  }
+  json_object_put(json_obj);
+  return ret;
+ error:
+  return -1;
+}
+
+str str_username_col = str_init("username");
+str str_domain_col = str_init("domain");
+str str_body_col = str_init("body");
+str str_expires_col = str_init("expires");
+str str_presentity_uri_col = str_init("presentity_uri");
+char* pres_uri_buf = NULL;
+int pres_uri_size = 0;
+
+int dbk_presence_query_expired(db1_res_t** _r) 
+{
+  /* TODO delete expired record */
+  
+  db1_res_t* db_res = db_new_result();
+  if ( db_res == NULL ) {
+    LM_ERR("no memory left\n");
+    return -1;
+  }
+  RES_ROW_N(db_res) = 0;
+  
+  *_r = db_res;
+  return 0;
+}
+
+
+int dbk_presence_query(const db1_con_t* _h, const db_key_t* _k,
+                       const db_val_t* _v, const db_key_t* _c, int _n, int _nc, db1_res_t** _r)
+{
+  str username = {0, 0};
+  str domain = {0, 0};
+  int i;
+  int uri_size;
+  unsigned int hash_code;
+  str pres_uri;
+  dbk_pres_user_t* pu;
+  dbk_pres_dialog_t* pd;
+  db1_res_t* db_res = NULL;
+  int col;
+  str body[BLF_MAX_DIALOGS];
+  int row_cnt = 0;
+  
+  if (_n == 2 && _k[0]->len == str_expires_col.len &&
+      strncmp(_k[0]->s, str_expires_col.s, str_expires_col.len) == 0 ) {
+    LM_DBG("dbk_presence_query goes to dbk_presence_query_expired\n");
+    return dbk_presence_query_expired(_r);
+  }
+  
+  for ( i = 0; i< _n; i++ ) {
+    if (username.len && domain.len)
+      break;
+    if (_k[i]->len == str_username_col.len &&
+        strncmp(_k[i]->s, str_username_col.s, str_username_col.len) == 0) {
+      username = _v[i].val.str_val;
+    } else
+      if (_k[i]->len == str_domain_col.len &&
+          strncmp(_k[i]->s, str_domain_col.s, str_domain_col.len) == 0) {
+        domain = _v[i].val.str_val;	
+      }
+  } 
+  if (!username.len || !domain.len) {
+    LM_ERR("Unsupported query - expected a query after username and domain\n");
+    return -1;
+  }
+  
+  uri_size = username.len + domain.len + 4;
+  if ( pres_uri_size < uri_size ) {
+    pres_uri_size = uri_size*2;
+    pres_uri_buf = (char*)pkg_realloc(pres_uri_buf, pres_uri_size);
+    if (pres_uri_buf == NULL) {
+      LM_ERR("No more private memory\n");
+      return 0;
+    }	
+  }
+  pres_uri.s = pres_uri_buf;
+  pres_uri.len = sprintf(pres_uri_buf, "sip:%.*s@%.*s", username.len, username.s, domain.len, domain.s);
+  
+  LM_DBG("dbk presence query %s\n", pres_uri.s);
+  
+  db_res = db_new_result();
+  if ( db_res == NULL ) {
+    LM_ERR("no memory left\n");
+    return -1;
+  }
+  RES_ROW_N(db_res) = 0;
+  
+  memset(body, 0, BLF_MAX_DIALOGS*sizeof(str));
+  
+  /* search in hash_table*/
+  hash_code = core_hash(&pres_uri, NULL, dbk_phtable_size);
+  
+  lock_get(&dbk_phtable[hash_code].lock);
+  pu = dbk_pres_search_pu(hash_code, &pres_uri, 0, 0);
+  
+  if ( pu == NULL ) {
+    LM_INFO("No dialog info found for user [%.*s]\n", pres_uri.len, pres_uri.s);
+    lock_release(&dbk_phtable[hash_code].lock);
+    *_r = db_res;
+    return 0;
+  }
+  LM_DBG("Found presence user record\n");
+  if ( pu->pd == NULL ) {
+    LM_ERR("Critical bad data in phtable: pu->pd == NULL\n");
+    goto error1;
+  }
+  pd = pu->pd;
+  row_cnt = 0;	
+  while ( pd != NULL && row_cnt < BLF_MAX_DIALOGS ) {
+    body[row_cnt].s = (char*)pkg_malloc(pu->pd->body.len + 1);
+    if (body[row_cnt].s == NULL) {
+      LM_ERR("No more shared memory\n");
+      goto error1;
+    }
+    memcpy(body[row_cnt].s, pu->pd->body.s, pu->pd->body.len);
+    body[row_cnt].len = pu->pd->body.len;
+    body[row_cnt].s[body[row_cnt].len] = '\0';
+    pd = pd->next;
+    row_cnt++;
+  } 
+  
+  lock_release(&dbk_phtable[hash_code].lock);
+  
+  LM_INFO("The user %.*s has %d active dialogs\n", pres_uri.len, pres_uri.s, row_cnt);
+  RES_COL_N(db_res) = _nc;
+  RES_ROW_N(db_res) = row_cnt;
+  if (db_allocate_rows(db_res) < 0) {
+    LM_ERR("Could not allocate rows.\n");
+    goto error2; 
+  }
+  
+  if (db_allocate_columns(db_res, RES_COL_N(db_res)) != 0) {
+    LM_ERR("Could not allocate columns\n");
+    goto error2;
+  }
+  for(col = 0; col < RES_COL_N(db_res); col++) {
+    RES_NAMES(db_res)[col] = (str*)pkg_malloc(sizeof(str));
+    if (! RES_NAMES(db_res)[col]) {
+      LM_ERR("no private memory left\n");
+      RES_COL_N(db_res) = col;
+      db_free_columns(db_res);
+      goto error2;
+    }
+    LM_DBG("Allocated %lu bytes for RES_NAMES[%d] at %p\n",
+           (unsigned long)sizeof(str), col, RES_NAMES(db_res)[col]);
+    
+    RES_NAMES(db_res)[col]->s = _c[col]->s;
+    RES_NAMES(db_res)[col]->len = _c[col]->len;
+    RES_TYPES(db_res)[col] = DB1_STR;
+    
+    LM_DBG("RES_NAMES(%p)[%d]=[%.*s]\n", RES_NAMES(db_res)[col], col,
+           RES_NAMES(db_res)[col]->len, RES_NAMES(db_res)[col]->s);
+  }
+  
+  for (i = 0; i< row_cnt; i++ ) {
+    if (db_allocate_row(db_res, &(RES_ROWS(db_res)[i])) != 0) {
+      LM_ERR("Could not allocate row.\n");
+      RES_ROW_N(db_res) = i;
+      while(--i >= 0) {
+        RES_ROWS(db_res)[i].values[col].free  = 0;
+      }
+      goto error2; 
+    }
+    
+    /* complete the row with the columns */
+    for(col = 0; col< _nc; col++) {
+      LM_DBG("Col[%d]: %.*s\n", col, _c[col]->len, _c[col]->s);
+      RES_ROWS(db_res)[0].values[col].type = DB1_STR;
+      if (strncmp(_c[col]->s, "body", _c[col]->len) == 0 ) {
+        RES_ROWS(db_res)[i].values[col].val.str_val = body[i];
+        RES_ROWS(db_res)[i].values[col].free  = 1;
+        RES_ROWS(db_res)[i].values[col].nul  = 0;
+        LM_INFO("Body in result: [%s]\n", RES_ROWS(db_res)[i].values[col].val.string_val);
+      } else {
+        RES_ROWS(db_res)[i].values[col].val.str_val.s = "";
+        RES_ROWS(db_res)[i].values[col].val.str_val.len = 0;
+        RES_ROWS(db_res)[i].values[col].free  = 0;
+        RES_ROWS(db_res)[i].values[col].nul  = 1;
+      } 
+    }
+  }
+  
+  LM_DBG("Returned [%d] rows\n", row_cnt);
+  *_r = db_res;
+  return 0;
+  
+ error1:
+  lock_release(&dbk_phtable[hash_code].lock);
+ error2:
+  for (i = 0; i< row_cnt; i++) {
+    if (!body[i].s)
+      break;
+    pkg_free(body[i].s);
+  }
+  db_free_result(db_res);
+  return -1;
+}
+
+int dbk_dialoginfo_update(const db1_con_t* _h, const db_key_t* db_col,
+                          const db_val_t* db_val, const int _n)
+{
+  json_object *json_object = NULL;
+  rmq_conn_t* rmq = (rmq_conn_t*)_h->tail;
+  amqp_bytes_t amqp_mb;
+  static amqp_bytes_t routing_key= {3, "BLF"};
+  str from_user = db_val[0].val.str_val;
+  str to_user   = db_val[1].val.str_val;
+  str state     = db_val[2].val.str_val;
+  str callid    = db_val[3].val.str_val;
+  str from_tag  = db_val[4].val.str_val;
+  str to_tag    = db_val[5].val.str_val;
+  str unique_string;  
+  
+  if (!rmq->conn && rmqp_open_connection(rmq) < 0) {
+    LM_WARN("disconnected from AMQP, dropping presence update\n");
+    goto error;
+  }
+  
+  if (_n != 6) {
+    LM_ERR("Inconsistency, expected 6 columns\n");
+    goto error;
+  }
+
+  LM_INFO("Dialog info update %.*s/%.*s %.*s %.*s\n",
+          from_user.len, from_user.s
+          ,to_user.len, to_user.s
+          ,callid.len, callid.s
+          ,state.len, state.s);
+  
+  /* construct json */	
+  
+  json_object = json_object_new_object();
+  if ( is_error(json_object) ) {
+    LM_ERR("Error constructing new json object: %s\n",
+           json_tokener_errors[-(unsigned long)json_object]);
+    goto error;
+  } 
+  
+  json_object_object_add(json_object, BLF_JSON_FROM, json_object_new_string_len(from_user.s, from_user.len));
+  json_object_object_add(json_object, BLF_JSON_TO, json_object_new_string_len(to_user.s, to_user.len));
+  json_object_object_add(json_object, BLF_JSON_STATE, json_object_new_string_len(state.s, state.len));
+  json_object_object_add(json_object, BLF_JSON_CALLID, json_object_new_string_len(callid.s, callid.len));
+  json_object_object_add(json_object, BLF_JSON_FROMTAG, json_object_new_string_len(from_tag.s, from_tag.len));
+  json_object_object_add(json_object, BLF_JSON_TOTAG, json_object_new_string_len(to_tag.s, to_tag.len));
+  json_object_object_add(json_object, BLF_JSON_EVENT_CATEGORY, json_object_new_string("presence"));
+  json_object_object_add(json_object, BLF_JSON_EVENT_NAME, json_object_new_string("update"));
+  tmb.generate_callid(&unique_string);
+  json_object_object_add(json_object, BLF_JSON_MSG_ID, json_object_new_string_len(unique_string.s, unique_string.len));
+  
+  amqp_mb.bytes = (char*)json_object_to_json_string(json_object);
+  if (amqp_mb.bytes == NULL) {
+    LM_ERR("Failed to get json string\n");
+    goto error;
+  }
+  amqp_mb.len   = strlen(amqp_mb.bytes); 
+  LM_DBG("AMQP: body: %s\n", (char*)amqp_mb.bytes);
+  
+  /* send to rabbitmq */
+  
+  LM_DBG("AMQP: exchange [%.*s]\n", (int)rmq->exchange.len, (char*)rmq->exchange.bytes);
+  LM_DBG("AMQP: channel %d\n", rmq->channel);
+  LM_DBG("AMQP: routing key [%s]\n", (char*)blf_queue.bytes);
+  LM_DBG("AMQP: body: %s\n", (char*)amqp_mb.bytes);
+  
+  amqp_basic_properties_t props;
+  memset(&props, 0, sizeof(amqp_basic_properties_t));
+  props._flags = AMQP_BASIC_CONTENT_TYPE_FLAG;
+  props.content_type = amqp_cstring_bytes("application/json");
+    
+  if (amqp_basic_publish(rmq->conn,
+                         rmq->channel,
+                         rmq->exchange,
+                         routing_key,
+                         0,
+                         0,
+                         &props,
+                         amqp_mb) < 0) {    
+    LM_WARN("failed to publish presence update\n");
+    rmq_close(rmq);
+    goto error;
+  }
+
+  json_object_put(json_object);
+  
+  return 0;
+ error:
+  if ( json_object )
+    json_object_put(json_object);
+  return -1;
+}
+
+int dbk_mi_print_pu(struct mi_node* rpl, dbk_pres_user_t* pu, int hash_code)
+{
+  dbk_pres_dialog_t* pd;
+  struct mi_node* node= NULL;
+  struct mi_node* node1 = NULL;
+  int len;
+  char* p;
+  int dlg_count = 0;
+  
+  node = add_mi_node_child(rpl, 0, "User", 4, pu->user.s, pu->user.len);
+  if (node==0) {
+    LM_ERR("Failed to add User node\n");
+    goto error;
+  }
+  
+  if (addf_mi_attr( node, 0, "hash", 4, "%u", hash_code) == 0) {
+    LM_ERR("Failed to add hash attribute\n");
+    goto error;
+  }
+  
+  for (pd = pu->pd; pd; pd = pd->next, dlg_count++) {
+    
+    p= int2str(dlg_count, &len);
+    if ( (node1= add_mi_node_child(node, MI_DUP_VALUE, "Dialog", 6, p, len)) == 0) {
+      LM_ERR("Failed to add Dialog node\n");
+      goto error;
+    }
+    
+    if (add_mi_node_child(node1, MI_DUP_VALUE, "callid", 6,
+                          pd->callid.s, pd->callid.len) == 0) {
+      LM_ERR("Failed to add callid\n");
+      goto error;
+    }
+    if (add_mi_node_child(node1, MI_DUP_VALUE, "local-tag", 9,
+                          pd->localtag.s, pd->localtag.len) == 0) {
+      LM_ERR("Failed to add from-tag\n");
+      goto error;
+    }
+    if (add_mi_node_child(node1, MI_DUP_VALUE, "remote-tag", 10,
+                          pd->remotetag.s, pd->remotetag.len) == 0) {
+      LM_ERR("Failed to add to-tag\n");
+      goto error;
+    }
+    if (add_mi_node_child(node1, MI_DUP_VALUE, "body", 4,
+                          pd->body.s, pd->body.len) == 0) {
+      LM_ERR("Failed to add body\n");
+      goto error;
+    }
+  }
+  
+  return 0;
+ error:
+  return -1;
+  
+}
+
+struct mi_root * mi_dbk_phtable_dump(struct mi_root *cmd_tree, void *param)
+{
+  int i;
+  dbk_pres_user_t* pu;
+  struct mi_root* rpl_tree= NULL;
+  struct mi_node* rpl = NULL;
+  
+  rpl_tree = init_mi_tree( 200, MI_SSTR(MI_OK));
+  if (rpl_tree==0)
+    return 0;
+  rpl = &rpl_tree->node;
+  
+  for (i = 0; i< dbk_phtable_size; i++) {
+    lock_get(&dbk_phtable[i].lock);
+    for (pu = dbk_phtable[i].pu; pu; pu = pu->next) {
+      if (dbk_mi_print_pu(rpl, pu, i)!=0)
+        goto error;
+    }
+    lock_release(&dbk_phtable[i].lock);
+  }	
+  
+  return rpl_tree;
+  
+ error:
+  lock_release(&dbk_phtable[i].lock);
+  LM_ERR("Failed to print pres htable\n");
+  return 0;
+}
+
+int dbk_presence_subscribe_alert_kazoo(rmq_conn_t* rmq, str* user,unsigned int expires, str* from_user)
+{
+  static amqp_bytes_t exchange = {15, "dialoginfo_subs"};
+  static amqp_bytes_t routing_key = {15, "dialoginfo_subs"};
+  static amqp_bytes_t amqp_mb;
+  json_object *json_object = NULL;
+  str unique_string;
+  
+  if (!rmq->conn && rmqp_open_connection(rmq) < 0) {
+    LM_WARN("disconnected from AMQP, dropping presence subsciption\n");
+    goto error;
+  }
+  
+  json_object = json_object_new_object();
+  if ( is_error(json_object) ) {
+    LM_ERR("Error constructing new json object: %s\n",
+           json_tokener_errors[-(unsigned long)json_object]);
+    goto error;
+  } 
+  
+  LM_INFO("Subscription %.*s/%.*s expires in %d\n"
+          ,from_user->len, from_user->s
+          ,user->len, user->s
+          ,expires-(int)time(NULL));
+  
+  json_object_object_add(json_object, BLF_JSON_USER, json_object_new_string_len(user->s, user->len));
+  json_object_object_add(json_object, BLF_JSON_FROM, json_object_new_string_len(from_user->s, from_user->len));
+  json_object_object_add(json_object, BLF_JSON_QUEUE, json_object_new_string_len(blf_queue.bytes, blf_queue.len));
+  json_object_object_add(json_object, BLF_JSON_EXPIRES, json_object_new_int(expires-(int)time(NULL)));
+  json_object_object_add(json_object, BLF_JSON_APP_NAME, json_object_new_string(NAME));
+  json_object_object_add(json_object, BLF_JSON_APP_VERSION, json_object_new_string(VERSION));
+  json_object_object_add(json_object, BLF_JSON_NODE, json_object_new_string(node_name));
+  json_object_object_add(json_object, BLF_JSON_SERVERID, json_object_new_string_len(blf_queue.bytes, blf_queue.len));
+  json_object_object_add(json_object, BLF_JSON_EVENT_CATEGORY, json_object_new_string("presence"));
+  json_object_object_add(json_object, BLF_JSON_EVENT_NAME, json_object_new_string("subscription"));
+  tmb.generate_callid(&unique_string);
+  json_object_object_add(json_object, BLF_JSON_MSG_ID, json_object_new_string_len(unique_string.s, unique_string.len));
+  
+  amqp_mb.bytes = (char*)json_object_to_json_string(json_object);
+  if (amqp_mb.bytes == NULL) {
+    LM_ERR("Failed to get json string\n");
+    goto error;
+  }
+  amqp_mb.len   = strlen(amqp_mb.bytes); 
+  LM_DBG("AMQP: body: %s\n", (char*)amqp_mb.bytes);
+  
+  /* send to rabbitmq */
+  
+  //LM_DBG("AMQP: exchange [%.*s]\n", (int)rmq->exchange.len, (char*)rmq->exchange.bytes);
+  LM_DBG("AMQP: exchange [%.*s]\n", (int)exchange.len, (char*)exchange.bytes);
+  LM_DBG("AMQP: channel %d\n", rmq->channel);
+  LM_DBG("AMQP: routing key [%s]\n", (char*)routing_key.bytes);
+  LM_DBG("AMQP: body: %s\n", (char*)amqp_mb.bytes);
+  
+  amqp_basic_properties_t props;
+  memset(&props, 0, sizeof(amqp_basic_properties_t));
+  props._flags = AMQP_BASIC_CONTENT_TYPE_FLAG;
+  props.content_type = amqp_cstring_bytes("application/json");
+    
+  if (amqp_basic_publish(rmq->conn,
+                         rmq->channel,
+                         exchange,
+                         routing_key,
+                         0,
+                         0,
+                         &props,
+                         amqp_mb) < 0) {
+    LM_WARN("failed to publish presence subsciption\n");
+    rmq_close(rmq);
+    goto error;
+  }
+  
+  json_object_put(json_object);
+  
+  return 0;
+ error:
+  if ( json_object )
+    json_object_put(json_object);
+  return -1;
+}
+
+int dbk_presence_subscribe_new(const db1_con_t* _h, const db_key_t* db_col,
+                               const db_val_t* db_val, const int _n)
+{
+  unsigned int expires = 0;
+  str user= {0, 0};
+  int i;
+  struct cell* t;
+  pv_value_t value;
+  
+  for (i = 0; i< _n; i++) {
+    if (db_col[i]->len == str_presentity_uri_col.len && 
+        strncmp(db_col[i]->s, str_presentity_uri_col.s, str_presentity_uri_col.len) == 0) {
+      user = db_val[i].val.str_val;
+    } else if (db_col[i]->len == str_expires_col.len && 
+               strncmp(db_col[i]->s, str_expires_col.s, str_expires_col.len) == 0) {
+      expires = db_val[i].val.int_val;
+      if (user.s) break;
+    }
+  }
+  
+  LM_DBG("i=%d expires=%u\n", i, expires);
+  if (i == _n) {
+    LM_ERR("Wrong formated sql insert\n");
+    return -1;
+  }
+  
+  /* save in hash table the presentity_uri for this callid */
+  t = tmb.t_gett();
+  if (t == NULL || t->uas.request == NULL) {
+    LM_ERR("No tm transaction or no sip msg found\n");
+    return -1;
+  }
+  value.flags = PV_VAL_STR;
+  value.rs = user;
+  if (pv_set_spec_value(t->uas.request, &sht_spec, 0, &value) < 0) {
+    LM_ERR("Failed to add sht value\n");
+  }
+  LM_DBG("Stored $sht(dbk=>%.*s)=[%.*s]\n", t->callid.len,  t->callid.s, value.rs.len, value.rs.s);
+  
+  return dbk_presence_subscribe_alert_kazoo((rmq_conn_t*)_h->tail, &user,
+                                            expires, &((to_body_t*)t->uas.request->from->parsed)->uri);
+}
+
+
+int dbk_presence_subscribe_update(const db1_con_t* _h, const db_key_t* _k,
+                                  const db_val_t* _v, const db_key_t* _uk, const db_val_t* _uv,
+                                  const int _n, const int _un)
+{
+  unsigned int expires = 0;
+  int i;
+  struct cell* t;
+  pv_value_t value;
+  value.rs.len = 0;
+  
+  for (i = 0; i< _n; i++) {
+    if (_uk[i]->len == str_expires_col.len && 
+        strncmp(_uk[i]->s, str_expires_col.s, str_expires_col.len) == 0) {
+      expires = _uv[i].val.int_val;
+      break;
+    }
+  }
+  
+  if (i == _n) {
+    LM_DBG("Not an expires update\n");
+    return 0;
+  }
+  
+  /* get user from sht */
+  t = tmb.t_gett();
+  if (t == NULL || t->uas.request == NULL) {
+    LM_ERR("No tm transaction or no sip msg found\n");
+    return -1;
+  }
+  if (pv_get_spec_value(t->uas.request, &sht_spec, &value) < 0) {
+    LM_ERR("Failed to get sht value\n");
+    return -1;
+  }
+  
+  /* set it again to reset expires */
+  if (pv_set_spec_value(t->uas.request, &sht_spec, 0, &value) < 0) {
+    LM_ERR("Failed to add sht value\n");
+  }	
+  if (value.rs.len == 0) {
+    LM_DBG("Failed to get the presentity uri from $sht, take it from request To header\n");
+    value.rs = ((to_body_t*)t->uas.request->to->parsed)->uri;
+    LM_DBG("Took presentity_uri from To header=[%.*s]\n", value.rs.len, value.rs.s);
+  } else {
+    LM_DBG("Found presentity_uri $sht(dbk=>%.*s)=[%.*s]\n", t->callid.len,  t->callid.s, value.rs.len, value.rs.s);
+  }
+  return dbk_presence_subscribe_alert_kazoo((rmq_conn_t*)_h->tail, &value.rs,
+                                            expires, &((to_body_t*)t->uas.request->from->parsed)->uri);
+}
diff --git a/modules/db_kazoo/blf.h b/modules/db_kazoo/blf.h
new file mode 100644
index 0000000..3df3113
--- /dev/null
+++ b/modules/db_kazoo/blf.h
@@ -0,0 +1,25 @@
+#ifndef _DBK_BLF_
+#define _DBK_BLF_
+
+#include "../../lib/srdb1/db_id.h"
+#include "../../mi/mi_types.h"
+#include "dbase.h"
+
+int dbk_initialize_presence(void);
+void dbk_start_presence_rmqp_consumer_processes(struct db_id* id);
+void dbk_destroy_presence(void);
+int dbk_presence_query(const db1_con_t* _h, const db_key_t* _k,
+		const db_val_t* _v, const db_key_t* _c, int _n, int _nc, db1_res_t** _r);
+int dbk_dialoginfo_update(const db1_con_t* _h, const db_key_t* db_col,
+				const db_val_t* db_val, const int _n);
+struct mi_root * mi_dbk_phtable_dump(struct mi_root *cmd_tree, void *param);
+struct mi_root * mi_dbk_phtable_flush(struct mi_root *cmd_tree, void *param);
+int dbk_presence_subscribe_new(const db1_con_t* _h, const db_key_t* db_col,
+				const db_val_t* db_val, const int _n);
+int dbk_presence_subscribe_update(const db1_con_t* _h, const db_key_t* _k,
+				const db_val_t* _v, const db_key_t* _uk, const db_val_t* _uv,
+				const int _n, const int _un);
+
+#define DBK_PRES_WORKERS_NO 6
+
+#endif
diff --git a/modules/db_kazoo/db_kazoo.c b/modules/db_kazoo/db_kazoo.c
new file mode 100644
index 0000000..8b2d3a5
--- /dev/null
+++ b/modules/db_kazoo/db_kazoo.c
@@ -0,0 +1,208 @@
+/*
+ * $Id$
+ *
+ * Kazoo module interface
+ *
+ * Copyright (C) 2013 2600Hz
+ *
+ * This file is part of Kamailio, a free SIP server.
+ *
+ * Kamailio is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version
+ *
+ * Kamailio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License 
+ * along with this program; if not, write to the Free Software 
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * History:
+ * --------
+ * 2013-04  first version (Anca Vamanu)
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+
+#include "../../sr_module.h"
+#include "../../lib/srdb1/db.h"
+#include "../../dprint.h"
+#include "../../lib/kmi/mi.h"
+#include "../tm/tm_load.h"
+
+#include "dbase.h"
+#include "blf.h"
+
+static int mod_init(void);
+static void mod_destroy(void);
+int db_kazoo_bind_api(db_func_t *dbb);
+
+str dbk_node_hostname={0, 0};
+str dbk_reg_fs_path={0, 0};
+int dbk_auth_wait_timeout = 3;
+int dbk_reconn_retries = 8;
+int use_contact_for_reg_notice = 0;
+int tm_bound = 0;
+struct tm_binds tmb;
+
+MODULE_VERSION
+
+/*
+ *  database module interface
+ */
+static cmd_export_t cmds[] = {
+	{"db_bind_api",  (cmd_function)db_kazoo_bind_api, 0, 0, 0},
+	{0, 0, 0, 0, 0}
+};
+
+
+static param_export_t params[] = {
+	{"node_hostname",     STR_PARAM, &dbk_node_hostname.s},
+	{"register_fs_path",  STR_PARAM, &dbk_reg_fs_path.s  },
+	{"auth_wait_timeout", INT_PARAM, &dbk_auth_wait_timeout},
+	{"reconn_retries",    INT_PARAM, &dbk_reconn_retries},
+        {"use_contact_for_reg_notice", INT_PARAM, &use_contact_for_reg_notice},
+	{0, 0, 0}
+};
+static mi_export_t mi_cmds[] = {
+	{ "presence_list",    mi_dbk_phtable_dump,   0,  0,  0},
+	{ "presence_flush",   mi_dbk_phtable_flush,  0,  0,  0},
+	{ 0, 0, 0, 0, 0}
+};
+
+struct module_exports exports = {
+	"db_kazoo",
+	DEFAULT_DLFLAGS, /* dlopen flags */
+	cmds,
+	params,          /* module parameters */
+	0,               /* exported statistics */
+	mi_cmds,         /* exported MI functions */
+	0,               /* exported pseudo-variables */
+	0,               /* extra processes */
+	mod_init,        /* module initialization function */
+	0,               /* response function*/
+	mod_destroy,     /* destroy function */
+	0                /* per-child init function */
+};
+
+static int mod_init(void)
+{
+	if(register_mi_mod(exports.name, mi_cmds)!=0)
+	{
+		LM_ERR("failed to register MI commands\n");
+		return -1;
+	}
+
+	register_procs(DBK_PRES_WORKERS_NO);
+	
+	if (dbk_node_hostname.s == NULL) {
+		LM_ERR("You must set the node_hostname parameter\n");
+		return -1;
+	}
+	dbk_node_hostname.len = strlen(dbk_node_hostname.s);
+	
+	if (dbk_reg_fs_path.s) dbk_reg_fs_path.len = strlen(dbk_reg_fs_path.s);
+
+	/* load all TM stuff */
+	if(!tm_bound) 
+        {
+            if(load_tm_api(&tmb)==-1)
+	    {
+		LM_ERR("Can't load tm functions. Module TM not loaded?\n");
+		return -1;
+	    }
+            tm_bound = 1;
+        }
+
+	return 0;
+}
+
+db1_con_t *db_kazoo_init(const str* _url)
+{
+	return db_do_init(_url,  (void* (*)()) db_kazoo_new_connection);
+}
+
+
+/*!
+ * \brief Close database when the database is no longer needed
+ * \param _h closed connection, as returned from db_kazoo_init
+ * \note free all memory and resources
+ */
+void db_kazoo_close(db1_con_t* _h)
+{
+	db_do_close(_h, (void (*)()) db_kazoo_free_connection);
+}
+
+/*
+ * Store name of table that will be used by
+ * subsequent database functions
+ */
+int db_kazoo_use_table(db1_con_t* _h, const str* _t)
+{
+	return db_use_table(_h, _t);
+}
+
+int db_kazoo_free_result(db1_con_t* _h, db1_res_t* _r) {
+	return db_free_result(_r);
+}
+
+int db_kazoo_delete (const db1_con_t* _h, const db_key_t* _k, const db_op_t* _o,
+				const db_val_t* _v, const int _n)
+{	
+	return 0;
+}
+
+int db_kazoo_raw_query (const db1_con_t* _h, const str* _s, db1_res_t** _r)
+{
+	return 0;
+}
+
+int db_kazoo_replace (const db1_con_t* handle, const db_key_t* keys,
+			const db_val_t* vals, const int n, const int _un, const int _m)
+{
+	return 0;
+}
+
+int db_kazoo_bind_api(db_func_t *dbb)
+{
+	if(dbb==NULL)
+		return -1;
+
+	/* load all TM stuff */
+	if(!tm_bound) 
+        {
+            if(load_tm_api(&tmb)==-1)
+	    {
+		LM_ERR("Can't load tm functions. Module TM not loaded?\n");
+		return -1;
+	    }
+            tm_bound = 1;
+        }
+	memset(dbb, 0, sizeof(db_func_t));
+
+	dbb->init             = db_kazoo_init;
+	dbb->use_table        = db_kazoo_use_table;
+	dbb->close            = db_kazoo_close;
+	dbb->query            = db_kazoo_query;
+	dbb->free_result      = db_kazoo_free_result;
+	dbb->insert           = db_kazoo_insert;
+	dbb->replace          = db_kazoo_replace;
+	dbb->insert_update    = db_kazoo_insert_update;
+	dbb->delete           = db_kazoo_delete;
+	dbb->update           = db_kazoo_update;
+	dbb->raw_query        = db_kazoo_raw_query;
+	dbb->cap              = DB_CAP_ALL;
+
+	return 0;
+}
+
+static void mod_destroy(void)
+{
+	dbk_destroy_presence();
+}
+
diff --git a/modules/db_kazoo/dbase.c b/modules/db_kazoo/dbase.c
new file mode 100644
index 0000000..284e0bf
--- /dev/null
+++ b/modules/db_kazoo/dbase.c
@@ -0,0 +1,939 @@
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <amqp.h>
+#include <amqp_framing.h>
+#include <amqp_tcp_socket.h>
+#include <json/json.h>
+#include <sys/time.h>
+#include <unistd.h>
+#include "../../lib/srdb1/db.h"
+#include "../../lib/srdb1/db_id.h"
+#include "../../lib/srdb1/db_pool.h"
+#include "../../dprint.h"
+#include "../../mem/mem.h"
+#include "../../sr_module.h"
+
+#include "dbase.h"
+#include "blf.h"
+
+int connections = 0;
+
+void rmq_close(rmq_conn_t* rmq)
+{
+  LM_DBG("Close rmq connection\n");
+  if (!rmq)
+    return;
+  
+  if (rmq->channel) {
+    LM_DBG("close channel: %d rmq(%p)->channel(%d)\n", getpid(), (void *)rmq, rmq->channel);
+    rmq_error("closing channel",
+              amqp_channel_close(rmq->conn, rmq->channel,
+                                 AMQP_REPLY_SUCCESS));
+    rmq->channel = 0;
+  }
+  
+  if (rmq->conn) {
+    LM_DBG("close connection:  %d rmq(%p)->conn(%p)\n", getpid(), (void *)rmq, rmq->conn);
+    rmq_error("closing connection",
+              amqp_connection_close(rmq->conn, AMQP_REPLY_SUCCESS));
+    
+    if (amqp_destroy_connection(rmq->conn) < 0) {
+      LM_ERR("cannot destroy connection\n");
+    }
+    rmq->conn = NULL;
+    rmq->socket = NULL;
+    rmq->channel = 0;
+  } else if (rmq->socket) {
+    LM_DBG("close socket: %d rmq(%p)->socket(%p)\n", getpid(), (void *)rmq, (void *)rmq->socket);
+    amqp_socket_close(rmq->socket);
+    rmq->socket = NULL;
+  }
+}
+
+int rmqp_open_connection(rmq_conn_t* rmq)
+{
+
+  LM_DBG("%d rmq:%p  conn:%p  socket:%p  channel:%d\n", getpid(), (void *)rmq, rmq->conn, (void *)rmq->socket, rmq->channel);
+
+  rmq->socket = amqp_tcp_socket_new();
+  if (!rmq->socket) {
+    LM_DBG("Failed to create TCP socket to AMQP broker\n");
+    goto error;
+  }
+  
+  /* TODO - take as module parameters */
+  if ( amqp_socket_open(rmq->socket, rmq->id->host, rmq->id->port) ) {
+    LM_DBG("Failed to open TCP socket to AMQP broker\n");
+    goto error;
+  }
+
+  if (!(rmq->conn = amqp_new_connection())) {
+    LM_DBG("Failed to create new AMQP connection\n");
+    goto error;
+  }
+    
+  amqp_set_socket(rmq->conn, rmq->socket);
+  
+  if ( rmq_error("Logging in", amqp_login(rmq->conn,
+                                          "/",
+                                          0,
+                                          131072,
+                                          0,
+                                          AMQP_SASL_METHOD_PLAIN,
+                                          rmq->id->username,
+			rmq->id->password)) ) {
+    LM_ERR("Login to AMQP broker failed!\n");
+    goto error;
+  }
+  
+  rmq->channel = process_no + 1;
+  amqp_channel_open(rmq->conn, rmq->channel);
+  if (rmq_error("Opening channel", amqp_get_rpc_reply(rmq->conn))) {
+    LM_ERR("Failed to open channel AMQP %d!\n", rmq->channel);
+    goto error;
+  }
+  
+  return 0;
+  
+ error:
+  rmq_close(rmq);
+  return -1;
+}
+
+rmq_conn_t* dbk_dummy_db_conn(struct db_id* id)
+{
+	rmq_conn_t* rmq;
+	int db_len = strlen(id->database);
+	int size = sizeof(rmq_conn_t) + db_len;
+
+	rmq = (rmq_conn_t*)pkg_malloc(size);
+	if (!rmq) {
+		LM_ERR("No more private memory\n");
+		return NULL;
+	}
+	memset(rmq, 0, size);
+	rmq->id = id;
+	rmq->ref = 1;
+
+	LM_DBG("Created new dummy rmq structure %p for %s\n", rmq, id->database);
+
+	rmq->exchange.bytes = (char*)rmq+ sizeof(rmq_conn_t);
+	memcpy(rmq->exchange.bytes, id->database, db_len);
+	rmq->exchange.len = db_len;
+
+	LM_DBG("Return dummy db conn\n");
+	return rmq;
+}
+	
+
+int presence_initialized = 0;
+void* db_kazoo_new_connection(struct db_id* id)
+{
+  LM_DBG("New db connection to exchange %s for %d process %d\n", id->database, getpid(), process_no);
+  if (strncmp(id->database, "dialoginfo", 10) == 0) {
+    if (process_no == 0 && !presence_initialized) {
+      if(dbk_initialize_presence() < 0) {
+        LM_ERR("Failed to initialize db_kazoo for presence");
+        return NULL;
+      }
+      presence_initialized = 1;
+    }
+    if (process_no == 1) {
+      LM_DBG("Start presence rmqp consumer processes\n");
+      dbk_start_presence_rmqp_consumer_processes(id);
+    }
+  }
+
+  return dbk_dummy_db_conn(id);
+}
+
+
+/*!
+ * \brief Close the connection and release memory
+ * \param connection
+ */
+void db_kazoo_free_connection(struct pool_con* con)
+{
+  rmq_conn_t * _c;
+  
+  LM_DBG("Close connection\n");
+  
+  if (!con) return;
+  _c = (rmq_conn_t*) con;
+  
+  rmq_close(_c);
+  pkg_free(_c);
+}
+
+#define KEY_SAFE(C)  ((C >= 'a' && C <= 'z') || \
+                      (C >= 'A' && C <= 'Z') || \
+                      (C >= '0' && C <= '9') || \
+                      (C == '-' || C == '~'  || C == '_'))
+
+#define HI4(C) (C>>4)
+#define LO4(C) (C & 0x0F)
+
+
+#define hexint(C) (C < 10?('0' + C):('A'+ C - 10))
+
+char* amqp_util_encode(const str* key, char* dest)
+{
+  if ( (key->len == 1) && (key->s[0] == '#' || key->s[0] == '*') ) {
+    *dest++ = key->s[0];
+    return dest;
+  }
+  char* p, *end;
+  for (p = key->s, end = key->s + key->len; p < end; p++) {
+    if (KEY_SAFE(*p)) {
+      *dest++= *p;
+    } else if (*p == '.' ) {
+      memcpy(dest, "\%2E", 3);
+      dest+= 3;
+    } else if (*p == ' ') {
+      *dest++ = '+';
+    } else {
+      *dest++='%';
+      sprintf(dest, "%c%c", hexint(HI4(*p)), hexint(LO4(*p)));
+      dest+=2;
+    }
+  }
+  return dest;
+}
+
+#if 0
+encode(<<"*">>) -> <<"*">>;
+encode(<<"#">>) -> <<"#">>;
+encode(Bin) -> << <<(encode_char(B))/binary>> || <<B>> <= Bin >>.
+
+-define(HI4(C), (C band 2#11110000) bsr 4).
+-define(LO4(C), (C band 2#00001111)).
+
+encode_char(C) when ?KEY_SAFE(C) -> <<C>>;
+encode_char($\s) -> <<$+>>;
+encode_char($.) -> <<$%, $2, $E>>;
+encode_char(C) ->
+    Hi4 = ?HI4(C),
+    Lo4 = ?LO4(C),
+    <<$%, (hexint(Hi4)), (hexint(Lo4))>>.
+
+}
+#endif
+
+#define AUTH_ROUTING_KEY_PREFIX "authn.req."
+#define AUTH_ROUTING_KEY_PREFIX_LEN sizeof("authn.req.") - 1
+
+#define REG_ROUTING_KEY_PREFIX "registration.success."
+#define REG_ROUTING_KEY_PREFIX_LEN sizeof("registration.success.") - 1
+
+static unsigned long rpl_routing_key_count = 0;
+
+db1_res_t* dbk_creds_build_result(char* body, const db_key_t* _c, int _nc) {
+  struct json_object *json_obj;	
+  struct json_object *init_json_obj = NULL;	
+  db1_res_t* db_res = 0;
+  str password;
+  int col;
+  
+  db_res = db_new_result();
+  if (!db_res) {
+    LM_ERR("no memory left\n");
+    return NULL;
+  }
+  RES_ROW_N(db_res) = 0;
+  
+  json_obj = json_tokener_parse(body);
+  if (is_error(json_obj)) {
+    LM_ERR("Error parsing json: %s\n",
+           json_tokener_errors[-(unsigned long)json_obj]);
+    goto error;
+  }
+  init_json_obj = json_obj;
+  
+  struct json_object* password_obj = json_object_object_get(json_obj, "Auth-Password");
+  if (is_error(json_obj)) {
+    LM_ERR("Error parsing json: %s\n",
+           json_tokener_errors[-(unsigned long)json_obj]);
+    goto error;
+  }
+  password.s = (char*)json_object_get_string(password_obj);
+  if (password.s == NULL) {
+    LM_ERR("Json-c error - failed to extract password [%s]\n", body);
+    goto error;
+  }
+  password.len = strlen(password.s);
+  LM_DBG("Password: [%s]\n", password.s);
+  
+  RES_COL_N(db_res) = _nc;
+  RES_ROW_N(db_res) = 1;
+  if (db_allocate_rows(db_res) < 0) {
+    LM_ERR("Could not allocate rows.\n");
+    goto error; 
+  }
+  
+  if (db_allocate_columns(db_res, RES_COL_N(db_res)) != 0) {
+    LM_ERR("Could not allocate columns\n");
+    goto error;
+  }
+  if (db_allocate_row(db_res, &(RES_ROWS(db_res)[0])) != 0) {
+    LM_ERR("Could not allocate row.\n");
+    goto error; 
+  }
+  
+  for(col = 0; col < RES_COL_N(db_res); col++) {
+    RES_NAMES(db_res)[col] = (str*)pkg_malloc(sizeof(str));
+    if (! RES_NAMES(db_res)[col]) {
+      LM_ERR("no private memory left\n");
+      RES_COL_N(db_res) = col;
+      db_free_columns(db_res);
+      goto error;
+    }
+    LM_DBG("Allocated %lu bytes for RES_NAMES[%d] at %p\n",
+           (unsigned long)sizeof(str), col, RES_NAMES(db_res)[col]);
+    
+    RES_NAMES(db_res)[col]->s = _c[col]->s;
+    RES_NAMES(db_res)[col]->len = _c[col]->len;
+    RES_TYPES(db_res)[col] = DB1_STR;
+    
+    LM_DBG("RES_NAMES(%p)[%d]=[%.*s]\n", RES_NAMES(db_res)[col], col,
+           RES_NAMES(db_res)[col]->len, RES_NAMES(db_res)[col]->s);
+  }
+  
+  
+  /* complete the row with the columns */
+  for(col = 0; col< _nc; col++) {
+    LM_DBG("Col[%d]: %.*s\n", col, _c[col]->len, _c[col]->s);
+    RES_ROWS(db_res)[0].values[col].type = DB1_STR;
+    if (strncmp(_c[col]->s, "password", _c[col]->len) == 0 ) {
+      LM_DBG("Wrote the password in the result\n");
+      
+      RES_ROWS(db_res)[0].values[col].val.str_val.s = (char*)pkg_malloc(password.len+1);
+      if (RES_ROWS(db_res)[0].values[col].val.str_val.s==NULL) {
+        PKG_MEM_ERROR;
+        goto error;
+      }
+      strcpy(RES_ROWS(db_res)[0].values[col].val.str_val.s, password.s);
+      RES_ROWS(db_res)[0].values[col].val.str_val.len = password.len;
+      
+      RES_ROWS(db_res)[0].values[col].free  = 1;
+      RES_ROWS(db_res)[0].values[col].nul  = 0;
+      LM_DBG("Password in result: [%s]\n", RES_ROWS(db_res)[0].values[col].val.string_val);
+    } else {
+      RES_ROWS(db_res)[0].values[col].val.str_val.s = "";
+      RES_ROWS(db_res)[0].values[col].val.str_val.len = 0;
+      RES_ROWS(db_res)[0].values[col].free  = 0;
+      RES_ROWS(db_res)[0].values[col].nul  = 1;
+    } 
+  }
+  //	RES_ROW_N(db_res) = 1;
+  
+  /* decrement the reference of the object*/
+  json_object_put(init_json_obj);
+  
+  return db_res;
+  
+ error:
+  if(init_json_obj)
+    json_object_put(init_json_obj);
+  return db_res;  
+}
+
+#define RET_AMQP_ERROR 2
+
+int dbk_credentials_query(const db1_con_t* _h, const db_key_t* _k,
+                          const db_val_t* _v, const db_key_t* _c, int _n, int _nc, db1_res_t** _r)
+{
+  rmq_conn_t* rmq = (rmq_conn_t*)_h->tail;
+  static char routingkey[256];
+  static char messagebody[2024];
+  static char serverid[256];
+  amqp_bytes_t amqp_rk;
+  amqp_bytes_t amqp_mb;
+  amqp_bytes_t rpl_queue= {0, 0};
+  amqp_bytes_t consumer_tag= {0, 0};
+  str unique_string = {0, 0};
+  int ret = -1;
+
+  if (!rmq->conn && rmqp_open_connection(rmq) < 0) {
+    LM_WARN("disconnected from AMQP, dropping authn request\n"); 
+    return ret;
+  }
+
+  LM_DBG("Query creds: %d rmq(%p)->conn(%p) %d\n", getpid(), (void *)rmq, rmq->conn, rmq->channel);
+
+  /* routingkey = authn.req._auth_realm_ */
+  amqp_rk.bytes = routingkey;
+  memcpy(routingkey, AUTH_ROUTING_KEY_PREFIX, AUTH_ROUTING_KEY_PREFIX_LEN);
+  amqp_rk.len = amqp_util_encode(&_v[1].val.str_val, routingkey+AUTH_ROUTING_KEY_PREFIX_LEN) - routingkey;
+  if (amqp_rk.len < AUTH_ROUTING_KEY_PREFIX_LEN + _v[1].val.str_val.len) {
+    LM_ERR("Encoding didn't succeed %.*s\n", (int)amqp_rk.len, (char*)amqp_rk.bytes);
+    return ret;
+  }
+  
+  tmb.generate_callid(&unique_string);
+
+  sprintf(serverid, "kamailio@%.*s-<%d>-%lu", _v[1].val.str_val.len, _v[1].val.str_val.s, my_pid(), rpl_routing_key_count++);
+  
+  /* construct messagebody */
+  amqp_mb.len = sprintf(messagebody, "{\"Method\":\"REGISTER\","
+                        "\"Auth-Realm\":\"%.*s\","
+                        "\"Auth-User\":\"%.*s\","
+                        "\"From\":\"%.*s@%.*s\","
+                        "\"To\":\"%.*s@%.*s\","
+                        "\"Server-ID\":\"%s\","
+                        "\"Node\":\"kamailio@%.*s\","
+                        "\"Msg-ID\":\"%.*s\","
+                        "\"App-Version\":\"%s\","
+                        "\"App-Name\":\"%s\","
+                        "\"Event-Name\":\"authn_req\","
+                        "\"Event-Category\":\"directory\"}",
+                        _v[1].val.str_val.len, _v[1].val.str_val.s,
+                        _v[0].val.str_val.len, _v[0].val.str_val.s,
+                        _v[0].val.str_val.len, _v[0].val.str_val.s,
+                        _v[1].val.str_val.len, _v[1].val.str_val.s,
+                        _v[0].val.str_val.len, _v[0].val.str_val.s,
+                        _v[1].val.str_val.len, _v[1].val.str_val.s,
+                        serverid,
+                        dbk_node_hostname.len, dbk_node_hostname.s,
+                        unique_string.len, unique_string.s,
+                        VERSION, NAME);
+  amqp_mb.bytes = messagebody;
+  
+  LM_DBG("AMQP: exchange %.*s\n", (int)rmq->exchange.len, (char*)rmq->exchange.bytes);
+  LM_DBG("AMQP: channel %d\n", rmq->channel);
+  LM_DBG("AMQP: routing key %.*s\n", (int)amqp_rk.len, (char*)amqp_rk.bytes);
+  LM_DBG("AMQP: body: %s\n", messagebody);
+  
+  /* Declare reply queue and start consumer */
+  amqp_bytes_t rpl_routing_key= {strlen(serverid), serverid};
+  
+  LM_DBG("AMQP: before queue_declare rpl_routing_key: [%.*s]\n", (int)rpl_routing_key.len, (char*)rpl_routing_key.bytes);
+  amqp_queue_declare_ok_t *r = amqp_queue_declare(rmq->conn, rmq->channel, amqp_empty_bytes, 0, 0, 1, 1,
+								 amqp_empty_table);
+  if (rmq_error("Declaring queue", amqp_get_rpc_reply(rmq->conn))) {
+    ret = -RET_AMQP_ERROR;
+    goto error;
+  }
+  
+  rpl_queue = amqp_bytes_malloc_dup(r->queue);
+  if (rpl_queue.bytes == NULL) {
+    LM_ERR("Out of memory while copying queue name\n");
+    goto error;
+  }
+  
+  amqp_bytes_t rpl_exch = {8, "targeted"};
+  if ( amqp_queue_bind(rmq->conn, rmq->channel,
+                       rpl_queue, rpl_exch, rpl_routing_key, amqp_empty_table) < 0 || 
+       rmq_error("Binding queue", amqp_get_rpc_reply(rmq->conn))) {
+    ret = -RET_AMQP_ERROR;
+    goto error;
+  }
+
+  amqp_basic_consume_ok_t *consume_ok = amqp_basic_consume(rmq->conn, rmq->channel, rpl_queue, amqp_empty_bytes, 0, 1, 1, amqp_empty_table);
+  if (rmq_error("Consuming", amqp_get_rpc_reply(rmq->conn))) {
+    ret = -RET_AMQP_ERROR;
+    goto error;      
+  }
+  consumer_tag = amqp_bytes_malloc_dup(consume_ok->consumer_tag);
+
+  LM_DBG("AMQP: after queue_bind  rpl_routing_key: [%.*s]\n", (int)rpl_routing_key.len, (char*)rpl_routing_key.bytes);
+  LM_DBG("AMQP: after queue_bind  server_id: [%s]\n", serverid);
+
+  /* publish  */
+  amqp_basic_properties_t props;
+  memset(&props, 0, sizeof(amqp_basic_properties_t));
+  props._flags = AMQP_BASIC_CONTENT_TYPE_FLAG;
+  props.content_type = amqp_cstring_bytes("application/json");
+  
+  if ( amqp_basic_publish(rmq->conn,
+                          rmq->channel,
+                          rmq->exchange,
+                          amqp_rk,
+                          0,
+                          0,
+                          &props,
+                          amqp_mb) < 0 || 
+       rmq_error("Publishing",  amqp_get_rpc_reply(rmq->conn)) ) {
+    LM_WARN("Failed to publish to AMQP, dropping authn request\n"); 
+    rmq_close(rmq);
+    ret = -RET_AMQP_ERROR;
+    goto error;
+  }
+  
+  LM_DBG("Published with success\n");
+  
+  amqp_frame_t frame;
+  int result;
+  
+  amqp_basic_deliver_t *d;
+  amqp_basic_properties_t *p;
+  size_t body_target;
+  size_t body_received = 0;
+  char body[2048];
+  
+  while (1) {
+    amqp_maybe_release_buffers(rmq->conn);
+    if (dbk_rmq_wait_for_data(rmq->conn) < 0 ) {
+      LM_ERR("RMQ data not ready - give up\n");
+      ret = -RET_AMQP_ERROR;
+      goto error;
+    }
+    result = amqp_simple_wait_frame(rmq->conn, &frame);
+    LM_DBG("Result: %d\n", result);
+    if (result < 0) {
+      rmq_close(rmq);
+      ret = -RET_AMQP_ERROR;
+      goto error;
+    }
+    
+    LM_DBG("Frame type: %d channel: %d\n", frame.frame_type, frame.channel);
+    if (frame.frame_type != AMQP_FRAME_METHOD) {
+      continue;
+    }
+    
+    LM_DBG("Method: %s\n", amqp_method_name(frame.payload.method.id));
+    if (frame.payload.method.id != AMQP_BASIC_DELIVER_METHOD) {
+      continue;
+    }
+    
+    d = (amqp_basic_deliver_t *) frame.payload.method.decoded;
+    LM_DBG("Delivery: %u exchange: %.*s routingkey: %.*s\n",
+           (unsigned) d->delivery_tag,
+           (int) d->exchange.len, (char *) d->exchange.bytes,
+           (int) d->routing_key.len, (char *) d->routing_key.bytes);
+    
+    if (dbk_rmq_wait_for_data(rmq->conn) < 0 ) {
+      LM_ERR("RMQ data not ready - give up\n");
+      ret = -RET_AMQP_ERROR;
+      goto error;
+    }
+    result = amqp_simple_wait_frame(rmq->conn, &frame);
+    if (result < 0) {
+      rmq_close(rmq);
+      ret = -RET_AMQP_ERROR;
+      goto error;
+    }
+    
+    if (frame.frame_type != AMQP_FRAME_HEADER) {
+      LM_ERR("amqp: Expected header!");
+      goto error;
+    }
+    p = (amqp_basic_properties_t *) frame.payload.properties.decoded;
+    if (p->_flags & AMQP_BASIC_CONTENT_TYPE_FLAG) {
+      LM_DBG("Content-type: %.*s\n",
+             (int) p->content_type.len, (char *) p->content_type.bytes);
+    }
+    
+    body_target = frame.payload.properties.body_size;
+    body_received = 0;
+    
+    while (body_received < body_target) {
+      if (dbk_rmq_wait_for_data(rmq->conn) < 0 ) {
+        LM_ERR("RMQ data not ready - give up\n");
+        ret = -RET_AMQP_ERROR;
+        goto error;
+      }
+      result = amqp_simple_wait_frame(rmq->conn, &frame);
+      if (result < 0) {
+        rmq_close(rmq);
+        ret = -RET_AMQP_ERROR;
+        goto error;
+      }
+      
+      if (frame.frame_type != AMQP_FRAME_BODY) {
+        LM_ERR("amqp: Expected header!");
+        goto error;
+      }
+      
+      memcpy(body + body_received, frame.payload.body_fragment.bytes,
+             frame.payload.body_fragment.len);
+      
+      body_received += frame.payload.body_fragment.len;
+      
+      LM_DBG("%.*s\n", (int)frame.payload.body_fragment.len,
+             (char*)frame.payload.body_fragment.bytes);
+    }
+    
+    if (body_received != body_target) {
+      LM_CRIT("Unexpected body size: recv %zu, expected %zu\n",
+              body_received, body_target);
+      goto error;
+    }
+
+    /* everything was fine, we can quit now because we received the reply */
+    break;
+  }
+  
+  body[body_received] = '\0';
+  LM_DBG("Received reply %s\n", body);
+  
+  /* parse json and extract password */
+  db1_res_t* db_res = dbk_creds_build_result(body, _c, _nc);	
+  *_r = db_res;
+  ret = 0;
+
+ error:
+  if(consumer_tag.bytes) {
+    amqp_basic_cancel(rmq->conn, rmq->channel, consumer_tag);
+    if (rmq_error("Canceling consumer", amqp_get_rpc_reply(rmq->conn))) {
+      LM_ERR("Failed to cancel consumer\n");
+    }
+    LM_DBG("consumer_tag [%.*s]\n", (int)consumer_tag.len, (char*)consumer_tag.bytes);
+    
+    amqp_bytes_free(consumer_tag);
+  }
+  if(rpl_queue.bytes) {
+    amqp_queue_delete(rmq->conn, rmq->channel, rpl_queue, 0, 0);
+    if (rmq_error("Deleting reply queue", amqp_get_rpc_reply(rmq->conn))) {
+      LM_ERR("Failed to delete queue\n");
+    }
+    LM_DBG("rpl_queue [%.*s]\n", (int)rpl_queue.len, (char*)rpl_queue.bytes);
+    
+    amqp_bytes_free(rpl_queue);
+  }
+  
+  return ret;
+}
+
+db1_res_t* db_empty_result(void)
+{
+  db1_res_t* db_res = db_new_result();
+  if (!db_res) {
+    LM_ERR("no memory left\n");
+    return NULL;
+  }
+  RES_ROW_N(db_res) = 0;
+  return db_res;
+}
+
+/*
+ * Query table for specified rows
+ * _h: structure representing database connection
+ * _k: key names
+ * _op: operators
+ * _v: values of the keys that must match
+ * _c: column names to return
+ * _n: number of key=values pairs to compare
+ * _nc: number of columns to return
+ * _o: order by the specified column
+ */
+int db_kazoo_query(const db1_con_t* _h, const db_key_t* _k, const db_op_t* _op,
+                   const db_val_t* _v, const db_key_t* _c, int _n, int _nc,
+                   const db_key_t _o, db1_res_t** _r)
+{
+  if (!_h || !CON_TABLE(_h) || !_r) {
+    LM_ERR("invalid parameter value\n");
+    return -1;
+  }
+  LM_DBG("query table=%s\n", _h->table->s);
+  
+  if(strncmp(_h->table->s, "subscriber", 10)== 0 ) {
+    return dbk_credentials_query(_h, _k, _v, _c, _n, _nc, _r);
+  } else if(strncmp(_h->table->s, "presentity", 10)== 0 ) {
+    return dbk_presence_query(_h, _k, _v, _c, _n, _nc, _r);
+  } else {
+    LM_DBG("Not supported\n");
+    *_r = db_empty_result();
+    return 0;
+  }
+}
+
+int amqp_register_notice(const db1_con_t* _h, const db_key_t* _k,
+                         const db_val_t* _v, const int _n) {  
+  rmq_conn_t* rmq = (rmq_conn_t*)_h->tail;
+  static char routingkey[256];
+  static char messagebody[2024];
+  static char fspath_buf[64];
+  static char recv_buf[64];
+  amqp_bytes_t amqp_rk;
+  amqp_bytes_t amqp_mb;
+  int col;
+  str unique_string;
+  str fs_path;
+  
+  str user= {0,0};
+  str contact = {0, 0};
+  int expires = 0;
+  
+  str callid = {0, 0};
+  str user_agent = {0, 0};
+  str network_ip = {0, 0};
+  str network_port = {0, 0};
+  str network_proto = {0, 0};
+  str host = {0, 0};
+  str received = {0, 0};
+
+  if (!rmq->conn && rmqp_open_connection(rmq) < 0) {
+    LM_WARN("disconnected from AMQP, dropping register success\n"); 
+    goto error;
+  }
+
+  /* construct messagebody */  
+  for (col = 0; col < _n; col ++) {
+    if (!user.len && strncmp(_k[col]->s, "username", 8) == 0) {
+      user = _v[col].val.str_val;
+    } else if (!contact.len && strncmp(_k[col]->s, "contact", 7) == 0) {
+      contact = _v[col].val.str_val;
+    } else if (!expires && strncmp(_k[col]->s, "expires", 7) == 0) {
+      expires= _v[col].val.int_val - (int)time(NULL);
+    } else if (!callid.len && strncmp(_k[col]->s, "callid", 6) == 0) {
+      callid = _v[col].val.str_val;
+    } else if (!user_agent.len && strncmp(_k[col]->s, "user_agent", 10) == 0) {
+      user_agent = _v[col].val.str_val;
+    } else if (!host.len && strncmp(_k[col]->s, "domain", 6) == 0) {
+      host = _v[col].val.str_val;
+    } else if (!network_ip.len && strncmp(_k[col]->s, "socket", 6) == 0) {
+      if (!_v[col].nul) {	
+        char* dp = memchr( _v[col].val.str_val.s, ':',  _v[col].val.str_val.len);
+        if (dp == NULL) {
+          LM_ERR("Wrong formated socket uri %.*s\n",
+                 _v[col].val.str_val.len, _v[col].val.str_val.s);
+          goto error;
+        }		
+        network_proto.s = _v[col].val.str_val.s;	
+        network_proto.len = dp - network_proto.s;	
+	
+        dp++;
+        network_ip.s = dp;	
+        dp = memchr(dp, ':',  _v[col].val.str_val.len- network_proto.len -1);
+        if (dp == NULL) {
+          LM_ERR("Wrong formated socket uri %.*s\n",
+                 _v[col].val.str_val.len, _v[col].val.str_val.s);
+          goto error;
+        }		
+        network_ip.len = dp - network_ip.s;
+        
+        network_port.s = dp + 1;
+        network_port.len = _v[col].val.str_val.s + _v[col].val.str_val.len - network_port.s;
+      } else {
+        LM_DBG("Null socket -> can not get the network IP and port\n");
+      }
+    } else if (!received.len && strncmp(_k[col]->s, "received", 8) == 0) {
+        if (use_contact_for_reg_notice) {
+          LM_DBG("use_contact_for_reg_notice - construct from contact\n");
+        } else if (!_v[col].nul) {
+          received = _v[col].val.str_val;
+        } else {
+          LM_DBG("NULL received - construct from contact\n");
+        }
+    }
+  }
+  
+  if (received.len == 0) {
+    struct sip_uri uri;
+    if (parse_uri(contact.s, contact.len, &uri) < 0) {
+      LM_ERR("Failed to parse contact URI\n");
+      goto error;
+    }
+    if (uri.user.len == 0) {
+      received = contact;
+    } else {
+      str port = uri.port;
+      if (port.len == 0) {
+        port.s = "5060";
+        port.len = 4;
+      }
+      received.s = recv_buf;
+      received.len = sprintf(received.s, "sip:%.*s:%.*s",
+                             uri.host.len, uri.host.s, port.len, port.s);
+    }
+    LM_DBG("Constructed received [%.*s]\n", received.len, received.s);
+  }
+  
+  LM_DBG("user = [%.*s]\n", user.len, user.s);
+  LM_DBG("host = [%.*s]\n", host.len, host.s);
+  LM_DBG("contact = [%.*s]\n", contact.len, contact.s);
+  LM_DBG("received = [%.*s]\n", received.len, received.s);
+  
+  /* take fs_path either from the module parameter or construct is as
+   * IP:PORT where the message was received */	
+  if (dbk_reg_fs_path.s) {
+    fs_path = dbk_reg_fs_path;
+  } else {
+    fs_path.s = fspath_buf;
+    fs_path.len = sprintf(fs_path.s, "%.*s:%.*s", network_ip.len, network_ip.s,
+                          network_port.len, network_port.s );
+  }
+  LM_DBG("fs_path = [%.*s]\n", fs_path.len, fs_path.s);
+  
+  /*
+   * {"Network-Port":"5065","Network-IP":"178.79.172.28","FreeSWITCH-Nodename":"freeswitch@kazoo2.anca-kazoo.com","FreeSWITCH-Hostname":"kazoo2.anca-kazoo.com","RPid":"unknown","To-Host":"sip.anca-kazoo.com","To-User":"twinkle","From-Host":"sip.anca-kazoo.com","From-User":"twinkle","Presence-Hosts":"n/a","Profile-Name":"sipinterface_1","Call-ID":"msbmplhjhlbrtrg@anca-vaio","User-Agent":"Twinkle/1.4.2","Status":"Registered(UDP)","Realm":"sip.anca-kazoo.com","Username":"twinkle","Expires":"3600","Contact":"\"anca\" <sip:twinkle@109.103.86.242:62038;fs_path=<sip:178.79.172.28:5065;lr;received='sip:109.103.86.242:62038'>>","Event-Timestamp":63534134448,"Server-ID":"","Node":"ecallmgr@kazoo2.anca-kazoo.com","Msg-ID":"75535250c50683a1056811c0931c4915","App-Version":"0.8.0","App-Name":"ecallmgr","Event-Name":"reg_success","Event-Category":"directory"}
+   *
+   *
+   */
+  tmb.generate_callid(&unique_string);
+  
+  amqp_mb.len = sprintf(messagebody, "{\"Network-Port\":\"%.*s\","
+                        "\"Network-IP\":\"%.*s\","
+                        "\"Kamailio-Hostname\":\"%.*s\","
+                        "\"RPid\":\"unknown\","
+                        "\"To-Host\":\"%.*s\","
+                        "\"To-User\":\"%.*s\","
+                        "\"From-Host\":\"%.*s\","
+                        "\"From-User\":\"%.*s\","
+                        "\"Presence-Hosts\":\"n/a\","
+                        "\"Profile-Name\":\"sipinterface_1\","
+                        "\"Call-ID\":\"%.*s\","
+                        "\"User-Agent\":\"%.*s\","
+                        "\"Status\":\"Registered(%.*s)\","
+                        "\"Realm\":\"%.*s\","
+                        "\"Username\":\"%.*s\","
+                        "\"Expires\":\"%d\","
+                        "\"Contact\":\"\\\"%.*s\\\" <sip:%.*s@%.*s;fs_path=<sip:%.*s;lr;received='%.*s'>>\","
+                        "\"Event-Timestamp\":\"%ld\","
+                        "\"Server-ID\":\"\","
+                        "\"Node\":\"kamailio@%.*s\","
+                        "\"Msg-ID\":\"%.*s\","
+                        "\"App-Version\":\"%s\","
+                        "\"App-Name\":\"%s\","
+                        "\"Event-Name\":\"reg_success\","
+                        "\"Event-Category\":\"directory\"} ",
+                        network_port.len, network_port.s,
+                        network_ip.len, network_ip.s,
+                        dbk_node_hostname.len, dbk_node_hostname.s,
+                        host.len, host.s,
+                        user.len, user.s,
+                        host.len, host.s,
+                        user.len, user.s,
+                        callid.len, callid.s,
+                        user_agent.len, user_agent.s,
+                        network_proto.len, network_proto.s,
+                        host.len, host.s,
+                        user.len, user.s,
+                        expires,
+                        user.len, user.s,
+                        user.len, user.s, received.len-4, received.s+4,
+                        fs_path.len, fs_path.s,
+                        //network_ip.len, network_ip.s, network_port.len, network_port.s,
+                        received.len, received.s,
+                        62167219200 + (int)time(NULL),
+                        dbk_node_hostname.len, dbk_node_hostname.s,
+                        unique_string.len, unique_string.s,
+                        VERSION, NAME );
+  amqp_mb.bytes = messagebody;
+  amqp_rk.bytes = routingkey;
+  memcpy(routingkey, REG_ROUTING_KEY_PREFIX, REG_ROUTING_KEY_PREFIX_LEN);
+  amqp_rk.len = amqp_util_encode(&host, routingkey+REG_ROUTING_KEY_PREFIX_LEN) - routingkey;
+  routingkey[amqp_rk.len++]='.';
+  amqp_rk.len = amqp_util_encode(&user, routingkey+amqp_rk.len) - routingkey;
+  if (amqp_rk.len < REG_ROUTING_KEY_PREFIX_LEN + host.len + user.len) {
+    LM_ERR("Encoding didn't succeed %.*s\n", (int)amqp_rk.len, (char*)amqp_rk.bytes);
+    return -1;
+  }
+  
+  LM_DBG("AMQP: exchange [%.*s]\n", (int)rmq->exchange.len, (char*)rmq->exchange.bytes);
+  LM_DBG("AMQP: channel %d\n", rmq->channel);
+  LM_DBG("AMQP: routing key [%.*s]\n", (int)amqp_rk.len, (char*)amqp_rk.bytes);
+  LM_DBG("AMQP: body: %s\n", messagebody);
+  
+  /* publish */
+  amqp_basic_properties_t props;
+  memset(&props, 0, sizeof(amqp_basic_properties_t));
+  props._flags = AMQP_BASIC_CONTENT_TYPE_FLAG;
+  props.content_type = amqp_cstring_bytes("application/json");
+
+  if (amqp_basic_publish(rmq->conn,
+                         rmq->channel,
+                         rmq->exchange,
+                         amqp_rk,
+                         0,
+                         0,
+                         &props,
+                         amqp_mb) < 0) {
+    LM_WARN("Failed to publish to AMQP, dropping registration success\n");
+    rmq_close(rmq);
+    goto error;
+  }
+
+  LM_DBG("Published with success\n");
+
+  return 0;
+  
+ error:
+  return -1;
+}
+
+int db_kazoo_insert (const db1_con_t* _h, const db_key_t* _k,
+                     const db_val_t* _v, const int _n)
+{
+  if (!_h || !CON_TABLE(_h) ) {
+    LM_ERR("invalid parameter value\n");
+    return -1;
+  }
+  LM_DBG("insert into table=%s\n", _h->table->s);
+  
+  if(strncmp(_h->table->s, "location", _h->table->len)  == 0) {
+    return amqp_register_notice(_h, _k, _v, _n);
+  } else if(strncmp(_h->table->s, "active_watchers", _h->table->len)  == 0) {
+    return dbk_presence_subscribe_new(_h, _k, _v, _n);
+  } else {
+    LM_DBG("Not supported\n");
+    return 0;
+  }
+}
+
+
+int db_kazoo_insert_update (const db1_con_t* _h, const db_key_t* _k,
+                            const db_val_t* _v, const int _n)
+{
+  if (!_h || !CON_TABLE(_h) ) {
+    LM_ERR("invalid parameter value\n");
+    return -1;
+  }
+  LM_DBG("insert into table=%s\n", _h->table->s);
+  
+  if(strncmp(_h->table->s, "dialoginfo", _h->table->len)  == 0) {
+    LM_DBG("Insert update called for dialoginfo table\n");
+    return dbk_dialoginfo_update(_h, _k, _v, _n);
+  } else {
+    LM_DBG("Not supported\n");
+    return 0;
+  }
+}
+
+int db_kazoo_update (const db1_con_t* _h, const db_key_t* _k, const db_op_t* _o,
+                     const db_val_t* _v, const db_key_t* _uk, const db_val_t* _uv,
+                     const int _n, const int _un) {
+  if(strncmp(_h->table->s, "active_watchers", _h->table->len)  == 0) {
+    LM_DBG("Update called for active_watchers table\n");
+    return dbk_presence_subscribe_update(_h, _k, _v, _uk, _uv, _n, _un);
+  } else {
+    LM_DBG("Not supported\n");
+    return 0;
+  }
+}
+
+int dbk_rmq_wait_for_data(amqp_connection_state_t conn)
+{
+  struct timeval timeout;
+  int sock;
+  fd_set read_flags;
+  int ret;
+  
+  if (amqp_data_in_buffer(conn)  || amqp_frames_enqueued(conn) ) {
+    return 0;
+  }
+  
+  sock = amqp_get_sockfd(conn);
+  FD_ZERO(&read_flags);
+  FD_SET(sock, &read_flags);
+  
+  timeout.tv_sec = dbk_auth_wait_timeout;
+  timeout.tv_usec = 0;
+  
+  ret = select(sock+1, &read_flags, NULL, NULL, &timeout);
+  if (ret == -1) {
+    LM_ERR("select: %s\n", strerror(errno));
+    return -1;
+  }
+  else if (ret == 0) {
+    LM_INFO("select: timeout\n");
+    return -1;
+  }
+  if (FD_ISSET(sock, &read_flags)) {
+    LM_INFO("select: data received\n");
+  }
+  
+  return 0;
+}
diff --git a/modules/db_kazoo/dbase.h b/modules/db_kazoo/dbase.h
new file mode 100644
index 0000000..64faded
--- /dev/null
+++ b/modules/db_kazoo/dbase.h
@@ -0,0 +1,101 @@
+#ifndef _DB_KAZOO_DBASE_
+#define _DB_KAZOO_DBASE_
+
+#include <amqp.h>
+#include "../../lib/srdb1/db.h"
+#include "../../lib/srdb1/db_id.h"
+#include "../../lib/srdb1/db_pool.h"
+#include "../tm/tm_load.h"
+
+extern str dbk_node_hostname;
+extern str dbk_reg_fs_path;
+extern int dbk_auth_wait_timeout;
+extern int dbk_reconn_retries;
+extern int use_contact_for_reg_notice;
+extern struct tm_binds tmb;
+
+typedef struct rmq_conn {
+	struct db_id* id;        /**< Connection identifier */
+	unsigned int ref;        /**< Reference count */
+	struct pool_con* next;   /**< Next element in the pool */
+
+	amqp_connection_state_t conn;
+	amqp_socket_t *socket;
+	int channel;
+	amqp_bytes_t exchange;
+	amqp_basic_properties_t props;
+        
+}rmq_conn_t;
+
+rmq_conn_t* dbk_dummy_db_conn(struct db_id* id);
+
+/* function that checks for error */
+static inline int rmq_error(char const *context, amqp_rpc_reply_t x)
+{
+	amqp_connection_close_t *mconn;
+	amqp_channel_close_t *mchan;
+
+	switch (x.reply_type) {
+		case AMQP_RESPONSE_NORMAL:
+			return 0;
+
+		case AMQP_RESPONSE_NONE:
+			LM_ERR("%s: missing RPC reply type!", context);
+			break;
+
+		case AMQP_RESPONSE_LIBRARY_EXCEPTION:
+			LM_ERR("%s: %s\n", context,  "(end-of-stream)");
+			break;
+
+		case AMQP_RESPONSE_SERVER_EXCEPTION:
+			switch (x.reply.id) {
+				case AMQP_CONNECTION_CLOSE_METHOD:
+					mconn = (amqp_connection_close_t *)x.reply.decoded;
+					LM_ERR("%s: server connection error %d, message: %.*s",
+							context, mconn->reply_code,
+							(int)mconn->reply_text.len,
+							(char *)mconn->reply_text.bytes);
+					break;
+				case AMQP_CHANNEL_CLOSE_METHOD:
+						mchan = (amqp_channel_close_t *)x.reply.decoded;
+					LM_ERR("%s: server channel error %d, message: %.*s",
+							context, mchan->reply_code,
+							(int)mchan->reply_text.len,
+							(char *)mchan->reply_text.bytes);
+					break;
+				default:
+					LM_ERR("%s: unknown server error, method id 0x%08X",
+							context, x.reply.id);
+					break;
+			}
+			break;
+	}
+	return -1;
+}
+
+
+void* db_kazoo_new_connection(struct db_id* id);
+
+int db_kazoo_query(const db1_con_t* _h, const db_key_t* _k, const db_op_t* _op,
+		const db_val_t* _v, const db_key_t* _c, int _n, int _nc,
+		const db_key_t _o, db1_res_t** _r);
+
+int db_kazoo_insert (const db1_con_t* _h, const db_key_t* _k,
+				const db_val_t* _v, const int _n);
+
+void db_kazoo_free_connection(struct pool_con* con);
+
+int db_kazoo_insert_update (const db1_con_t* _h, const db_key_t* _k,
+				const db_val_t* _v, const int _n);
+
+int db_kazoo_update (const db1_con_t* _h, const db_key_t* _k, const db_op_t* _o,
+				const db_val_t* _v, const db_key_t* _uk, const db_val_t* _uv,
+				const int _n, const int _un);
+
+int dbk_rmq_wait_for_data(amqp_connection_state_t conn);
+
+void rmq_close(rmq_conn_t* rmq);
+
+int rmqp_open_connection(rmq_conn_t* rmq);
+
+#endif
diff --git a/modules/dispatcher/dispatch.c b/modules/dispatcher/dispatch.c
index cc8b7bf..64b2f22 100644
--- a/modules/dispatcher/dispatch.c
+++ b/modules/dispatcher/dispatch.c
@@ -2213,7 +2213,7 @@ int ds_print_list(FILE *fout)
 /* Checks, if the request (sip_msg *_m) comes from a host in a group
  * (group-id or -1 for all groups)
  */
-int ds_is_from_list(struct sip_msg *_m, int group)
+int ds_is_from_list_no_port(struct sip_msg *_m, int group, int ignore_port)
 {
 	pv_value_t val;
 	ds_set_t *list;
@@ -2231,7 +2231,7 @@ int ds_is_from_list(struct sip_msg *_m, int group)
 			{
 				// LM_ERR("port no: %d (%d)\n", list->dlist[j].port, j);
 				if (ip_addr_cmp(&_m->rcv.src_ip, &list->dlist[j].ip_address)
-						&& (list->dlist[j].port==0
+						&& (ignore_port || list->dlist[j].port==0
 							|| _m->rcv.src_port == list->dlist[j].port))
 				{
 					if(group==-1 && ds_setid_pvname.s!=0)
@@ -2252,6 +2252,10 @@ int ds_is_from_list(struct sip_msg *_m, int group)
 	return -1;
 }
 
+int ds_is_from_list(struct sip_msg *_m, int group)
+{
+	return ds_is_from_list_no_port(_m, group, 0);
+}
 
 int ds_print_mi_list(struct mi_node* rpl)
 {
diff --git a/modules/dispatcher/dispatch.h b/modules/dispatcher/dispatch.h
index db055ee..4ab755f 100644
--- a/modules/dispatcher/dispatch.h
+++ b/modules/dispatcher/dispatch.h
@@ -119,6 +119,7 @@ int ds_load_update(struct sip_msg *msg);
 int ds_hash_load_init(unsigned int htsize, int expire, int initexpire);
 int ds_hash_load_destroy(void);
 
+int ds_is_from_list_no_port(struct sip_msg *_m, int group, int ignore_port);
 int ds_is_from_list(struct sip_msg *_m, int group);
 /*! \brief
  * Timer for checking inactive destinations
diff --git a/modules/dispatcher/dispatcher.c b/modules/dispatcher/dispatcher.c
index cf79d90..722d3db 100644
--- a/modules/dispatcher/dispatcher.c
+++ b/modules/dispatcher/dispatcher.c
@@ -155,6 +155,7 @@ static int w_ds_load_update(struct sip_msg*, char*, char*);
 
 static int w_ds_is_from_list0(struct sip_msg*, char*, char*);
 static int w_ds_is_from_list1(struct sip_msg*, char*, char*);
+static int w_ds_is_from_list2(struct sip_msg *msg, char *set, char *ignore_port);
 
 static void destroy(void);
 
@@ -182,6 +183,8 @@ static cmd_export_t cmds[]={
 		0, 0, REQUEST_ROUTE|FAILURE_ROUTE|ONREPLY_ROUTE|BRANCH_ROUTE},
 	{"ds_is_from_list",  (cmd_function)w_ds_is_from_list1, 1,
 		fixup_uint_null, 0, ANY_ROUTE},
+	{"ds_is_from_list",  (cmd_function)w_ds_is_from_list2, 2,
+		fixup_uint_uint, 0, ANY_ROUTE},
 	{"ds_load_unset",    (cmd_function)w_ds_load_unset,   0,
 		0, 0, ANY_ROUTE},
 	{"ds_load_update",   (cmd_function)w_ds_load_update,  0,
@@ -794,6 +797,13 @@ static int w_ds_is_from_list1(struct sip_msg *msg, char *set, char *str2)
 	return ds_is_from_list(msg, (int)(long)set);
 }
 
+static int w_ds_is_from_list2(struct sip_msg *msg, char *set, char *ignore_port)
+{
+	return ds_is_from_list_no_port(msg, (int)(long)set, (int)(long)ignore_port);
+}
+
+
+
 static int ds_parse_reply_codes() {
 	param_t* params_list = NULL;
 	param_t *pit=NULL;
diff --git a/modules/presence/bind_presence.c b/modules/presence/bind_presence.c
index 2392a81..6e518e4 100644
--- a/modules/presence/bind_presence.c
+++ b/modules/presence/bind_presence.c
@@ -72,7 +72,9 @@ int bind_presence(presence_api_t* api)
 	api->handle_publish= handle_publish;
 	api->handle_subscribe0= handle_subscribe0;
 	api->handle_subscribe= handle_subscribe;
+	api->notify_watchers = pres_notify_watchers;
 	return 0;
+
 }
 
 
diff --git a/modules/presence/bind_presence.h b/modules/presence/bind_presence.h
index a24ac19..f7ef155 100644
--- a/modules/presence/bind_presence.h
+++ b/modules/presence/bind_presence.h
@@ -48,6 +48,8 @@ typedef int (*pres_handle_publish_t)(struct sip_msg* msg, char *str1, char* str2
 typedef int (*pres_handle_subscribe0_t)(struct sip_msg* msg);
 typedef int (*pres_handle_subscribe_t)(struct sip_msg* msg, str watcher_user, str watcher_domain);
 
+typedef int (*pres_notify_watchers_t)(str* user_uri, str* event, str* body);
+
 typedef struct presence_api {
 	add_event_t add_event;
 	contains_event_t contains_event;
@@ -71,6 +73,7 @@ typedef struct presence_api {
 	pres_handle_publish_t handle_publish;
 	pres_handle_subscribe0_t handle_subscribe0;
 	pres_handle_subscribe_t handle_subscribe;
+	pres_notify_watchers_t notify_watchers;
 } presence_api_t;
 
 int bind_presence(presence_api_t* api);
diff --git a/modules/presence/hash.c b/modules/presence/hash.c
index c7d366a..1e1d2d5 100644
--- a/modules/presence/hash.c
+++ b/modules/presence/hash.c
@@ -352,7 +352,9 @@ int update_shtable(shtable_t htable,unsigned int hash_code,
 	else
 	{
 		subs->local_cseq = ++s->local_cseq;
-		subs->version = ++s->version;
+		subs->version = s->version;
+		s->version++;
+		LM_DBG("Version increased to %d\n", s->version);
 	}
 	
 	if(strncmp(s->contact.s, subs->contact.s, subs->contact.len))
diff --git a/modules/presence/notify.c b/modules/presence/notify.c
index 0a7ffb2..e7306aa 100644
--- a/modules/presence/notify.c
+++ b/modules/presence/notify.c
@@ -1541,6 +1541,14 @@ int send_notify_request(subs_t* subs, subs_t * watcher_subs,
 						notify_body= final_body;
 					}
 				}
+				if (notify_body && subs->event->aux_body_processing) {
+					final_body = subs->event->aux_body_processing(subs, notify_body);
+					if(final_body) {
+						xmlFree(notify_body->s);
+						pkg_free(notify_body);
+						notify_body= final_body;
+					}
+				}
 			}
 		}
 	}
@@ -3011,3 +3019,89 @@ void pres_timer_send_notify(unsigned int ticks, void *param)
 		return;
 	}
 }
+
+int pres_notify_watchers(str* pres_uri, str* event_str, str* body)
+{
+	event_t m_ev;
+	pres_ev_t* event;
+	struct sip_uri uri;
+	str *aux_body = NULL;
+	subs_t* subs_array= NULL, *s= NULL;
+	int ret_code= -1;
+	str user, domain;
+	str* notify_body = NULL;
+
+	memset(&m_ev, 0, sizeof(event_t));
+
+        LM_INFO("pres_notify_watchers %s %s %s\n", pres_uri->s, event_str->s, body->s);
+
+	if (event_parser(event_str->s, event_str->len, &m_ev) < 0) {
+		LM_ERR("failed to parse event\n");
+		return -1;
+	}
+
+	event= search_event(&m_ev);
+	if(event== NULL) {
+		LM_ERR("Event not supported\n");
+		return -1;
+	}
+	if (parse_uri(pres_uri->s, pres_uri->len, &uri) < 0) {
+		LM_ERR("Wrong formated uri\n");
+		return -1;
+	}
+	user = uri.user;
+	domain = uri.host;
+
+	subs_array= get_subs_dialog(pres_uri, event , NULL);
+	if(subs_array == NULL)
+	{
+		LM_DBG("Could not find subs_dialog\n");
+		ret_code= 0;
+		goto done;
+	}
+
+	/* if the event does not require aggregation - we have the final body */
+	if(body == NULL)
+	{	
+		notify_body = get_p_notify_body(*pres_uri, event , NULL, NULL);
+		if(notify_body == NULL)
+		{
+			LM_ERR("Could not get the notify_body\n");
+			goto done;
+		}
+	}
+
+	s= subs_array;
+	while(s)
+	{
+		if (event->aux_body_processing) {
+			LM_INFO("aux_body_processing defined\n");
+		      aux_body = event->aux_body_processing(s, notify_body?notify_body:body);
+//			LM_INFO("After auxiliary processing the body is [%.*s]\n", aux_body->len, aux_body->s);
+			LM_INFO("After auxiliary processing the body is [%.*s]\n", body->len, body->s);
+		}
+
+
+		if(notify(s, NULL, aux_body?aux_body:(notify_body?notify_body:body), 0)< 0 )
+		{
+			LM_ERR("Could not send notify for %.*s\n",
+					event->name.len, event->name.s);
+		}
+
+		if(aux_body!=NULL) {
+			if(aux_body->s)	{
+				event->aux_free_body(aux_body->s);
+			}
+			pkg_free(aux_body);
+		}
+		s= s->next;
+	}
+
+	ret_code= 0;
+
+done:
+	free_subs_list(subs_array, PKG_MEM_TYPE, 0);
+	free_notify_body(notify_body, event);	
+	return ret_code;
+}
+
diff --git a/modules/presence/notify.h b/modules/presence/notify.h
index 2eb91e4..ed5425d 100644
--- a/modules/presence/notify.h
+++ b/modules/presence/notify.h
@@ -124,4 +124,7 @@ char* get_status_str(int flag);
 str *get_p_notify_body(str pres_uri, pres_ev_t *event, str *etag, str *contact);
 void free_notify_body(str *body, pres_ev_t *ev);
 void pres_timer_send_notify(unsigned int ticks, void *param);
+
+int pres_notify_watchers(str* user_uri, str* event, str* body);
+
 #endif
diff --git a/modules/presence/presence.c b/modules/presence/presence.c
index ed7f4d1..80f86f7 100644
--- a/modules/presence/presence.c
+++ b/modules/presence/presence.c
@@ -134,6 +134,7 @@ char prefix='a';
 int startup_time=0;
 str db_url = {0, 0};
 int expires_offset = 0;
+int min_expires= 0;
 int max_expires= 3600;
 int shtable_size= 9;
 shtable_t subs_htable= NULL;
@@ -186,6 +187,7 @@ static param_export_t params[]={
 	{ "notifier_processes",     INT_PARAM, &pres_notifier_processes },
 	{ "to_tag_pref",            STR_PARAM, &to_tag_pref },
 	{ "expires_offset",         INT_PARAM, &expires_offset },
+	{ "min_expires",            INT_PARAM, &min_expires },
 	{ "max_expires",            INT_PARAM, &max_expires },
 	{ "server_address",         STR_PARAM, &server_address.s},
 	{ "subs_htable_size",       INT_PARAM, &shtable_size},
@@ -262,6 +264,12 @@ static int mod_init(void)
 	if(max_expires<= 0)
 		max_expires = 3600;
 
+	if(min_expires < 0)
+		min_expires = 0;
+
+	if(min_expires > max_expires)
+		min_expires = max_expires;
+
 	if(server_address.s== NULL)
 		LM_DBG("server_address parameter not set in configuration file\n");
 	
@@ -311,6 +319,8 @@ static int mod_init(void)
 		return -1;
 	}
 
+	
+	#if 0
 	/*verify table versions */
 	if((db_check_table_version(&pa_dbf, pa_db, &presentity_table, P_TABLE_VERSION) < 0) ||
 		(db_check_table_version(&pa_dbf, pa_db, &watchers_table, S_TABLE_VERSION) < 0)) {
@@ -323,6 +333,7 @@ static int mod_init(void)
 		LM_ERR("wrong table version for %s\n", active_watchers_table.s);
 		return -1;
 	}
+	#endif
 
 	if(subs_dbmode != DB_ONLY) {
 		if(shtable_size< 1)
@@ -336,7 +347,7 @@ static int mod_init(void)
 			LM_ERR(" initializing subscribe hash table\n");
 			return -1;
 		}
-		if(restore_db_subs()< 0)
+		if(subs_dbmode!=NO_DB && restore_db_subs()< 0)
 		{
 			LM_ERR("restoring subscribe info from database\n");
 			return -1;
@@ -356,11 +367,13 @@ static int mod_init(void)
 			return -1;
 		}
 
+#if 0
 		if(pres_htable_restore()< 0)
 		{
 			LM_ERR("filling in presentity hash table from database\n");
 			return -1;
 		}
+#endif
 	}
 
 	startup_time = (int) time(NULL);
@@ -392,10 +405,10 @@ static int mod_init(void)
 
 		register_basic_timers(pres_notifier_processes);
 	}
-
+#if 0
 	pa_dbf.close(pa_db);
 	pa_db = NULL;
-
+#endif
 	return 0;
 }
 
@@ -671,6 +684,7 @@ error:
 	return -1;
 }
 
+
 /*! \brief
  *  mi cmd: refreshWatchers
  *			\<presentity_uri> 
diff --git a/modules/presence/presence.h b/modules/presence/presence.h
index e064bb2..67306ec 100644
--- a/modules/presence/presence.h
+++ b/modules/presence/presence.h
@@ -76,6 +76,7 @@ extern int startup_time;
 extern char *to_tag_pref;
 extern int expires_offset;
 extern str server_address;
+extern int min_expires;
 extern int max_expires;
 extern int subs_dbmode;
 extern int publ_cache_enabled;
diff --git a/modules/presence/subscribe.c b/modules/presence/subscribe.c
index aff55f3..ab289c5 100644
--- a/modules/presence/subscribe.c
+++ b/modules/presence/subscribe.c
@@ -619,12 +619,12 @@ int update_subscription(struct sip_msg* msg, subs_t* subs, int to_tag_gen,
 		LM_DBG("subscription not in dialog\n");
 		if(subs->expires!= 0)
 		{
+			subs->version = 1;
 			if(subs_dbmode != DB_ONLY)
 			{
 				LM_DBG("inserting in shtable\n");
 				subs->db_flag = (subs_dbmode==WRITE_THROUGH)?WTHROUGHDB_FLAG:INSERTDB_FLAG;
 				hash_code= core_hash(&subs->pres_uri, &subs->event->name, shtable_size);
-				subs->version = 0;
 				if(insert_shtable(subs_htable,hash_code,subs)< 0)
 				{
 					LM_ERR("failed to insert new record in subs htable\n");
@@ -634,7 +634,6 @@ int update_subscription(struct sip_msg* msg, subs_t* subs, int to_tag_gen,
 
 			if(subs_dbmode == DB_ONLY || subs_dbmode == WRITE_THROUGH)
 			{
-				subs->version = 1;
 				if(insert_subs_db(subs, REMOTE_TYPE) < 0)
 				{
 					LM_ERR("failed to insert new record in database\n");
@@ -849,7 +848,7 @@ int handle_subscribe(struct sip_msg* msg, str watcher_user, str watcher_domain)
 		ev_param= ev_param->next;
 	}
 	
-	if(extract_sdialog_info(&subs, msg, max_expires, &to_tag_gen,
+	if(extract_sdialog_info(&subs, msg, min_expires, max_expires, &to_tag_gen,
 				server_address, watcher_user, watcher_domain)< 0)
 	{
 		LM_ERR("failed to extract dialog information\n");
@@ -1074,9 +1073,9 @@ error:
 }
 
 
-int extract_sdialog_info(subs_t* subs,struct sip_msg* msg, int mexp,
-		int* to_tag_gen, str scontact, str watcher_user,
-		str watcher_domain)
+int extract_sdialog_info(subs_t* subs,struct sip_msg* msg, int miexp,
+                int mexp, int* to_tag_gen, str scontact,
+                str watcher_user, str watcher_domain)
 {
 	str rec_route= {0, 0};
 	int rt  = 0;
@@ -1105,6 +1104,8 @@ int extract_sdialog_info(subs_t* subs,struct sip_msg* msg, int mexp,
 	}
 	if(lexpire > mexp)
 		lexpire = mexp;
+	if (lexpire && miexp && lexpire < miexp)
+                lexpire = miexp;
 
 	subs->expires = lexpire;
 
@@ -1384,7 +1385,7 @@ found_rec:
 	if(subs->pres_uri.s == NULL)
 		subs->pres_uri= pres_uri;
 
-	subs->version = s->version + 1;
+	subs->version = s->version;
 	subs->status= s->status;
 	if(s->reason.s && s->reason.len)
 	{
@@ -1552,7 +1553,7 @@ int get_database_info(struct sip_msg* msg, subs_t* subs, int* reply_code, str* r
 	}
 
 	subs->local_cseq= row_vals[local_cseq_col].val.int_val + 1;
-	subs->version= row_vals[version_col].val.int_val + 1;
+	subs->version= row_vals[version_col].val.int_val;
 
 	if(!EVENT_DIALOG_SLA(subs->event->evp))
 	{
diff --git a/modules/presence/subscribe.h b/modules/presence/subscribe.h
index 64938ca..5c37f84 100644
--- a/modules/presence/subscribe.h
+++ b/modules/presence/subscribe.h
@@ -113,10 +113,10 @@ void update_db_subs_timer(db1_con_t *db,db_func_t dbf, shtable_t hash_table,
 typedef void (*update_db_subs_t)(db1_con_t * ,db_func_t ,shtable_t ,int ,int ,
 		handle_expired_func_t);
 
-int extract_sdialog_info(subs_t* subs,struct sip_msg* msg, int max_expire,
+int extract_sdialog_info(subs_t* subs,struct sip_msg* msg, int min_expire, int max_expire,
 		int* to_tag_gen, str scontact, str watcher_user, str watcher_domain);
 typedef int (*extract_sdialog_info_t)(subs_t* subs, struct sip_msg* msg,
-		int max_expire, int* to_tag_gen, str scontact, str watcher_user,
+		int min_expire, int max_expire, int* to_tag_gen, str scontact, str watcher_user,
 		str watcher_domain);
 void delete_subs(str* pres_uri, str* ev_name, str* to_tag, str* from_tag, str* callid);
 
diff --git a/modules/presence_dialoginfo/bind_pres_dialoginfo.h b/modules/presence_dialoginfo/bind_pres_dialoginfo.h
new file mode 100644
index 0000000..c9174fa
--- /dev/null
+++ b/modules/presence_dialoginfo/bind_pres_dialoginfo.h
@@ -0,0 +1,28 @@
+
+#ifndef _BIND_PRES_DIALOGINFO_H_
+#define _BIND_PRES_DIALOGINFO_H_
+
+#include "../../sr_module.h"
+
+typedef str* (*agg_dialoginfo_t)(str*, str*, str**, int);
+
+typedef struct {
+	agg_dialoginfo_t agg_dialoginfo;
+} pres_dialoginfo_api_t;
+
+int bind_pres_dialoginfo(pres_dialoginfo_api_t* api);
+
+typedef int (*bind_pres_dialoginfo_t)(pres_dialoginfo_api_t* api);
+
+inline static int pres_dialoginfo_load_api(pres_dialoginfo_api_t* api)
+{
+	bind_pres_dialoginfo_t bind_pres_dialoginfo_exports;
+	if (!(bind_pres_dialoginfo_exports = (bind_pres_dialoginfo_t)find_export("bind_pres_dialoginfo", 1, 0)))
+	{
+		LM_ERR("Failed to import bind_pres_dialoginfo\n");
+		return -1;
+	}
+	return bind_pres_dialoginfo_exports(api);
+}
+
+#endif
diff --git a/modules/presence_dialoginfo/notify_body.c b/modules/presence_dialoginfo/notify_body.c
index cc65efb..705a054 100644
--- a/modules/presence_dialoginfo/notify_body.c
+++ b/modules/presence_dialoginfo/notify_body.c
@@ -46,7 +46,7 @@
 #include "notify_body.h"
 #include "pidf.h"
 
-str* agregate_xmls(str* pres_user, str* pres_domain, str** body_array, int n);
+str* agg_dialoginfo_xmls(str* pres_user, str* pres_domain, str** body_array, int n);
 extern int force_single_dialog;
 
 void free_xml_body(char* body)
@@ -66,10 +66,13 @@ str* dlginfo_agg_nbody(str* pres_user, str* pres_domain, str** body_array, int n
 	LM_DBG("[pres_user]=%.*s [pres_domain]= %.*s, [n]=%d\n",
 			pres_user->len, pres_user->s, pres_domain->len, pres_domain->s, n);
 
+//	if(body_array== NULL)
+//		return NULL;
+
 	if(body_array== NULL)
-		return NULL;
+		n = 0;
 
-	n_body= agregate_xmls(pres_user, pres_domain, body_array, n);
+	n_body= agg_dialoginfo_xmls(pres_user, pres_domain, body_array, n);
 	LM_DBG("[n_body]=%p\n", n_body);
 	if(n_body) {
 		LM_DBG("[*n_body]=%.*s\n",
@@ -81,12 +84,12 @@ str* dlginfo_agg_nbody(str* pres_user, str* pres_domain, str** body_array, int n
 	}
 
 	xmlCleanupParser();
-    xmlMemoryDump();
+    	xmlMemoryDump();
 
 	return n_body;
 }	
 
-str* agregate_xmls(str* pres_user, str* pres_domain, str** body_array, int n)
+str* agg_dialoginfo_xmls(str* pres_user, str* pres_domain, str** body_array, int n)
 {
 	int i, j= 0;
 
@@ -95,7 +98,7 @@ str* agregate_xmls(str* pres_user, str* pres_domain, str** body_array, int n)
 	xmlNsPtr   namespace = NULL;
 
 	xmlNodePtr p_root= NULL;
-	xmlDocPtr* xml_array ;
+	xmlDocPtr* xml_array = NULL;
 	xmlNodePtr node = NULL;
 	char *state;
 	int winner_priority = -1, priority ;
@@ -106,14 +109,16 @@ str* agregate_xmls(str* pres_user, str* pres_domain, str** body_array, int n)
 	LM_DBG("[pres_user]=%.*s [pres_domain]= %.*s, [n]=%d\n",
 			pres_user->len, pres_user->s, pres_domain->len, pres_domain->s, n);
 
-	xml_array = (xmlDocPtr*)pkg_malloc( n*sizeof(xmlDocPtr));
-	if(xml_array== NULL)
+	if (n) 
 	{
-		LM_ERR("while allocating memory");
-		return NULL;
+		xml_array = (xmlDocPtr*)pkg_malloc( n*sizeof(xmlDocPtr));
+		if(xml_array== NULL)
+		{
+			LM_ERR("while allocating memory");
+			return NULL;
+		}
+		memset(xml_array, 0, n*sizeof(xmlDocPtr)) ;
 	}
-	memset(xml_array, 0, n*sizeof(xmlDocPtr)) ;
-
 	/* parse all the XML documents */
 	for(i=0; i<n; i++)
 	{
@@ -134,12 +139,14 @@ str* agregate_xmls(str* pres_user, str* pres_domain, str** body_array, int n)
 
 	} 
 
-	if(j== 0)  /* no body */
-	{
-		if(xml_array)
-			pkg_free(xml_array);
-		return NULL;
-	}
+	/*
+        if(j== 0)
+        {
+        	if(xml_array)
+        		pkg_free(xml_array);
+         		return NULL;
+        }
+	*/
 
 	/* n: number of bodies in total */
 	/* j: number of useful bodies; created XML structures */
@@ -181,7 +188,7 @@ str* agregate_xmls(str* pres_user, str* pres_domain, str** body_array, int n)
 	   use signed int as presence module stores "version" in DB as
 	   signed int) has max. 10 characters + 1 character for the sign
 	*/
-    xmlNewProp(root_node, BAD_CAST "version", BAD_CAST "00000000000");
+    xmlNewProp(root_node, BAD_CAST "version", BAD_CAST VERSION_PH);
     xmlNewProp(root_node, BAD_CAST  "state",  BAD_CAST "full" );
     xmlNewProp(root_node, BAD_CAST "entity",  BAD_CAST buf);
 
@@ -297,7 +304,6 @@ int get_dialog_state_priority(char *state) {
 
 str *dlginfo_body_setversion(subs_t *subs, str *body) {
 	char *version_start=0;
-	char version[MAX_INT_LEN + 2]; /* +2 becasue of trailing " and \0 */
 	int version_len;
 
 	if (!body) {
@@ -319,21 +325,16 @@ str *dlginfo_body_setversion(subs_t *subs, str *body) {
 
 	/* safety check for placeholder - if it is body not set by the module,
 	 * don't update the version */
-	if(strncmp(version_start, "00000000000\"", 12)!=0)
+	if(strncmp(version_start, VERSION_PH, VERSION_PH_LEN)!=0)
 		return NULL;
 
-	version_len = snprintf(version, MAX_INT_LEN + 2,"%d\"", subs->version);
-	if (version_len >= MAX_INT_LEN + 2) {
-		LM_ERR("failed to convert 'version' to string\n");
-		memcpy(version_start, "00000000000\"", 12);
-		return NULL;
-	}
-	/* Replace the placeholder 00000000000 with the version.
+	/* Replace the placeholder 0000000000 with the version.
 	 * Put the padding behind the ""
 	 */
-	LM_DBG("replace version with \"%s\n",version);
-	memcpy(version_start, version, version_len);
-	memset(version_start + version_len, ' ', 12 - version_len);
 
+	version_len = sprintf(version_start, "%d\"", subs->version);
+	memset(version_start + version_len, ' ', VERSION_PH_LEN +1 - version_len);
+
+	LM_DBG("Replaced the version with \"%.*s\n",version_len-1, version_start);
 	return NULL;
 }
diff --git a/modules/presence_dialoginfo/notify_body.h b/modules/presence_dialoginfo/notify_body.h
index 838ddfe..42650e8 100644
--- a/modules/presence_dialoginfo/notify_body.h
+++ b/modules/presence_dialoginfo/notify_body.h
@@ -37,10 +37,17 @@
 #ifndef _NBODY_H_
 #define _NBODY_H_
 
+#include "../../str.h"
+#include "../presence/subscribe.h"
+
+#define VERSION_PH "0000000000"
+#define VERSION_PH_LEN sizeof(VERSION_PH) - 1
+
 str* dlginfo_agg_nbody(str* pres_user, str* pres_domain, str** body_array,
 		int n, int off_index);
 str* dlginfo_body_setversion(subs_t *subs, str* body);
 void free_xml_body(char* body);
 int get_dialog_state_priority(char *state);
+str* agg_dialoginfo_xmls(str* pres_user, str* pres_domain, str** body_array, int n);
 
 #endif
diff --git a/modules/presence_dialoginfo/presence_dialoginfo.c b/modules/presence_dialoginfo/presence_dialoginfo.c
index d071b52..d4242fd 100644
--- a/modules/presence_dialoginfo/presence_dialoginfo.c
+++ b/modules/presence_dialoginfo/presence_dialoginfo.c
@@ -40,6 +40,8 @@
 #include "../presence/bind_presence.h"
 #include "add_events.h"
 #include "presence_dialoginfo.h"
+#include "notify_body.h"
+#include "bind_pres_dialoginfo.h"
 
 MODULE_VERSION
 
@@ -55,6 +57,7 @@ int force_single_dialog = 0;
 /* module exported commands */
 static cmd_export_t cmds[] =
 {
+	{"bind_pres_dialoginfo", (cmd_function)bind_pres_dialoginfo, 1, 0, 0, 0},
     {0,	0, 0, 0, 0, 0}
 };
 
@@ -110,3 +113,16 @@ static int mod_init(void)
     
     return 0;
 }
+
+int bind_pres_dialoginfo(pres_dialoginfo_api_t* api)
+{
+	if (!api) {
+		LM_ERR("Invalid parameter value\n");
+		return -1;
+	}
+	
+	api->agg_dialoginfo = agg_dialoginfo_xmls;
+	return 0;
+}
+
+
diff --git a/modules/pua/pua.c b/modules/pua/pua.c
index 900e582..48f0534 100644
--- a/modules/pua/pua.c
+++ b/modules/pua/pua.c
@@ -207,11 +207,11 @@ static int mod_init(void)
 		return -1;
 	}
 	/* verify table version  */
-	if(db_check_table_version(&pua_dbf, pua_db, &db_table, PUA_TABLE_VERSION) < 0) {
+/*	if(db_check_table_version(&pua_dbf, pua_db, &db_table, PUA_TABLE_VERSION) < 0) {
 		LM_ERR("error during table version check.\n");
 		return -1;
 	}
-
+*/
 	if (dbmode != PUA_DB_ONLY)
 	{ 
 		if(HASH_SIZE<=1)
diff --git a/modules/pua_dialoginfo/Makefile b/modules/pua_dialoginfo/Makefile
index f99f41f..fbb9f43 100644
--- a/modules/pua_dialoginfo/Makefile
+++ b/modules/pua_dialoginfo/Makefile
@@ -19,5 +19,7 @@ else
 endif
 
 DEFS+=-DKAMAILIO_MOD_INTERFACE
+SERLIBPATH=../../lib
+SER_LIBS+=$(SERLIBPATH)/srdb1/srdb1
 
 include ../../Makefile.modules
diff --git a/modules/pua_dialoginfo/bind_dialoginfo.h b/modules/pua_dialoginfo/bind_dialoginfo.h
new file mode 100644
index 0000000..0a8e852
--- /dev/null
+++ b/modules/pua_dialoginfo/bind_dialoginfo.h
@@ -0,0 +1,29 @@
+
+#ifndef _BIND_DIALOGINFO_H_
+#define _BIND_DIALOGINFO_H_
+
+#include "../../sr_module.h"
+
+typedef str* (*build_dialoginfo_t)(char*, str*, str*, str*, 
+	unsigned int, str*, str*, str*, str*, int);
+
+typedef struct {
+	build_dialoginfo_t build_dialoginfo;
+} pua_dialoginfo_api_t;
+
+int bind_pua_dialoginfo(pua_dialoginfo_api_t* api);
+
+typedef int (*bind_pua_dialoginfo_t)(pua_dialoginfo_api_t* api);
+
+inline static int pua_dialoginfo_load_api(pua_dialoginfo_api_t* api)
+{
+	bind_pua_dialoginfo_t bind_pua_dialoginfo_exports;
+	if (!(bind_pua_dialoginfo_exports = (bind_pua_dialoginfo_t)find_export("bind_pua_dialoginfo", 1, 0)))
+	{
+		LM_ERR("Failed to import bind_pua_dialoginfo\n");
+		return -1;
+	}
+	return bind_pua_dialoginfo_exports(api);
+}
+
+#endif
diff --git a/modules/pua_dialoginfo/dialog_publish.c b/modules/pua_dialoginfo/dialog_publish.c
index 95b6cb3..2a769dc 100644
--- a/modules/pua_dialoginfo/dialog_publish.c
+++ b/modules/pua_dialoginfo/dialog_publish.c
@@ -37,6 +37,7 @@
 #include "../usrloc/usrloc.h"
 #include "../usrloc/ul_callback.h"
 #include "../../modules/tm/tm_load.h"
+#include "../../modules/presence_dialoginfo/notify_body.h"
 #include "../pua/pua.h"
 #include "pua_dialoginfo.h"
 
@@ -57,7 +58,7 @@ void print_publ(publ_info_t* p)
 
 str* build_dialoginfo(char *state, str *entity, str *peer, str *callid, 
 	unsigned int initiator, str *localtag, str *remotetag,
-	str *localtarget, str *remotetarget)
+	str *localtarget, str *remotetarget, int version)
 {
 	xmlDocPtr  doc = NULL; 
 	xmlNodePtr root_node = NULL;
@@ -73,7 +74,7 @@ str* build_dialoginfo(char *state, str *entity, str *peer, str *callid,
 		LM_ERR("entity URI '%.*s' too long, maximum=%d\n",entity->len, entity->s, MAX_URI_SIZE);
 		return NULL;
 	}
-    memcpy(buf, entity->s, entity->len);
+	memcpy(buf, entity->s, entity->len);
 	buf[entity->len]= '\0';
 
 	/* create the Publish body  */
@@ -81,23 +82,27 @@ str* build_dialoginfo(char *state, str *entity, str *peer, str *callid,
 	if(doc==0)
 		return NULL;
 
-    root_node = xmlNewNode(NULL, BAD_CAST "dialog-info");
+	root_node = xmlNewNode(NULL, BAD_CAST "dialog-info");
 	if(root_node==0)
 		goto error;
     
 	xmlDocSetRootElement(doc, root_node);
 
-    xmlNewProp(root_node, BAD_CAST "xmlns",
+	xmlNewProp(root_node, BAD_CAST "xmlns",
 			BAD_CAST "urn:ietf:params:xml:ns:dialog-info");
 	/* we set the version to 0 but it should be set to the correct value
        in the pua module */
-	xmlNewProp(root_node, BAD_CAST "version",
-			BAD_CAST "0");
+
+	xmlNewProp(root_node, BAD_CAST "version", BAD_CAST VERSION_PH);
 	xmlNewProp(root_node, BAD_CAST  "state",
 			BAD_CAST "full" );
 	xmlNewProp(root_node, BAD_CAST "entity", 
 			BAD_CAST buf);
 
+	if (!callid) {
+		LM_DBG("Empty dialog-info\n");
+		goto done;
+	}
 	/* RFC 3245 differs between id and call-id. For example if a call
 	   is forked and 2 early dialogs are established, we should send 2
 	    PUBLISH requests, both have the same call-id but different id.
@@ -119,7 +124,7 @@ str* build_dialoginfo(char *state, str *entity, str *peer, str *callid,
 		LM_ERR("call-id '%.*s' too long, maximum=%d\n", callid->len, callid->s, MAX_URI_SIZE);
 		return NULL;
 	}
-    memcpy(buf, callid->s, callid->len);
+	memcpy(buf, callid->s, callid->len);
 	buf[callid->len]= '\0';
 
 	xmlNewProp(dialog_node, BAD_CAST "id", BAD_CAST buf);
@@ -174,7 +179,7 @@ str* build_dialoginfo(char *state, str *entity, str *peer, str *callid,
 			LM_ERR("peer '%.*s' too long, maximum=%d\n", peer->len, peer->s, MAX_URI_SIZE);
 			return NULL;
 		}
-    	memcpy(buf, peer->s, peer->len);
+		memcpy(buf, peer->s, peer->len);
 		buf[peer->len]= '\0';
 
 		tag_node = xmlNewChild(remote_node, NULL, BAD_CAST "identity", BAD_CAST buf) ;
@@ -207,7 +212,7 @@ str* build_dialoginfo(char *state, str *entity, str *peer, str *callid,
 			LM_ERR("entity '%.*s' too long, maximum=%d\n", entity->len, entity->s, MAX_URI_SIZE);
 			return NULL;
 		}
-    	memcpy(buf, entity->s, entity->len);
+		memcpy(buf, entity->s, entity->len);
 		buf[entity->len]= '\0';
 
 		tag_node = xmlNewChild(local_node, NULL, BAD_CAST "identity", BAD_CAST buf) ;
@@ -229,6 +234,7 @@ str* build_dialoginfo(char *state, str *entity, str *peer, str *callid,
 		xmlNewProp(tag_node, BAD_CAST "uri", BAD_CAST buf);
 	}
 
+done:
 	/* create the body */
 	body = (str*)pkg_malloc(sizeof(str));
 	if(body == NULL)
@@ -260,6 +266,76 @@ error:
 	return NULL;
 }	
 
+/* {"From-User": "uri", "To-User": "uri", "New-State": "state", "Call-ID": "callid", 
+ *  "From-Tag": "tag", "To-tag": "tag"}
+ * {"Replaces": "", "Refered-By": ""} */
+
+static str from_user_col = str_init("from_user");
+static str to_user_col   = str_init("to_user");
+static str state_col     = str_init("state");
+static str callid_col    = str_init("callid");
+static str from_tag_col = str_init("from_tag");
+static str to_tag_col   = str_init("to_tag");
+
+void db_dialog_publish(char *state, str *from_user, str *to_user, str *callid,
+	str *from_tag, str *to_tag)
+{
+	db_key_t key[6];
+	db_val_t val[6];
+	int n = 0;	
+
+	memset(val, 0, 6*sizeof(db_val_t));
+
+	key[n] = &from_user_col;
+	val[n].type = DB1_STR;
+	val[n].val.str_val = *from_user;
+ 	n++;
+
+	key[n] = &to_user_col;
+	val[n].type = DB1_STR;
+	val[n].val.str_val = *to_user;
+ 	n++;
+ 
+	key[n] = &state_col;
+	val[n].type = DB1_STR;
+	val[n].val.str_val.s = state;
+	val[n].val.str_val.len = strlen(state);
+ 	n++;
+ 
+	key[n] = &callid_col;
+	val[n].type = DB1_STR;
+	val[n].val.str_val = *callid;
+ 	n++;
+ 
+	key[n] = &from_tag_col;
+	val[n].type = DB1_STR;
+	if (from_tag) {
+		val[n].val.str_val = *from_tag;
+	} else {
+		val[n].val.str_val.s = 0;
+		val[n].val.str_val.len = 0;
+	}
+ 	n++;
+
+	key[n] = &to_tag_col;
+	val[n].type = DB1_STR;
+	if (to_tag) {
+		val[n].val.str_val = *to_tag;
+	} else {
+		val[n].val.str_val.s = 0;
+		val[n].val.str_val.len = 0;
+	}
+ 	n++;
+	
+	if(pua_dialoginfo_dbf.use_table(pua_dialoginfo_db, &dialoginfo_db_table)< 0) {
+		LM_ERR("use table failed\n");
+	}
+
+	if (pua_dialoginfo_dbf.insert_update(pua_dialoginfo_db, key, val, n) < 0) {
+		LM_ERR("Insert update failed\n");
+	}
+}
+
 void dialog_publish(char *state, str* ruri, str *entity, str *peer, str *callid,
 	unsigned int initiator, unsigned int lifetime, str *localtag, str *remotetag,
 	str *localtarget, str *remotetarget, unsigned short do_pubruri_localcheck)
@@ -290,7 +366,7 @@ void dialog_publish(char *state, str* ruri, str *entity, str *peer, str *callid,
 	content_type.s= "application/dialog-info+xml";
 	content_type.len= 27;
 
-	body= build_dialoginfo(state, entity, peer, callid, initiator, localtag, remotetag, localtarget, remotetarget);
+	body= build_dialoginfo(state, entity, peer, callid, initiator, localtag, remotetag, localtarget, remotetarget, 0);
 	if(body == NULL || body->s == NULL)
 		goto error;
 	
@@ -377,14 +453,18 @@ error:
 }
 
 
-
 void dialog_publish_multi(char *state, struct str_list* ruris, str *entity, str *peer, str *callid,
 	unsigned int initiator, unsigned int lifetime, str *localtag, str *remotetag,
 	str *localtarget, str *remotetarget, unsigned short do_pubruri_localcheck) {
 
 	while(ruris) {
 		LM_INFO("CALLING dialog_publish for URI %.*s\n",ruris->s.len, ruris->s.s);
-		dialog_publish(state,&(ruris->s),entity,peer,callid,initiator,lifetime,localtag,remotetag,localtarget,remotetarget,do_pubruri_localcheck);
+		if ( pua_dialoginfo_db ) {
+			if (initiator)
+				db_dialog_publish(state, entity, peer, callid, localtag, remotetag);
+		} else {
+			dialog_publish(state,&(ruris->s),entity,peer,callid,initiator,lifetime,localtag,remotetag,localtarget,remotetarget,do_pubruri_localcheck);
+		}
 		ruris=ruris->next;
 	}
 
diff --git a/modules/pua_dialoginfo/pua_dialoginfo.c b/modules/pua_dialoginfo/pua_dialoginfo.c
index 9c842b0..e51ce70 100644
--- a/modules/pua_dialoginfo/pua_dialoginfo.c
+++ b/modules/pua_dialoginfo/pua_dialoginfo.c
@@ -46,10 +46,12 @@
 #include "../../str_list.h"
 #include "../../mem/mem.h"
 #include "../../pt.h"
+#include "../../lib/srdb1/db.h"
 #include "../dialog/dlg_load.h"
 #include "../dialog/dlg_hash.h"
 #include "../pua/pua_bind.h"
 #include "pua_dialoginfo.h"
+#include "bind_dialoginfo.h"
 
 MODULE_VERSION
 
@@ -92,16 +94,23 @@ int send_publish_flag = DEF_SEND_PUBLISH_FLAG;
 int use_pubruri_avps    = DEF_USE_PUBRURI_AVPS;
 char * pubruri_caller_avp  = DEF_PUBRURI_CALLER_AVP;
 char * pubruri_callee_avp  = DEF_PUBRURI_CALLEE_AVP;
-
+str db_url = {0, 0};
+str dialoginfo_db_table = str_init("dialoginfo");
+db1_con_t *pua_dialoginfo_db = NULL;
+db_func_t pua_dialoginfo_dbf;
+int library_mode = 0; 
 
 send_publish_t pua_send_publish;
 /** module functions */
 
 static int mod_init(void);
+static int child_init(int rank);
+static void mod_destroy(void);
 
 
 static cmd_export_t cmds[]=
 {
+	{"bind_pua_dialoginfo", (cmd_function)bind_pua_dialoginfo, 1, 0, 0, 0},
 	{0, 0, 0, 0, 0, 0} 
 };
 
@@ -116,6 +125,8 @@ static param_export_t params[]={
 	{"use_pubruri_avps",    INT_PARAM, &use_pubruri_avps },
 	{"pubruri_caller_avp",  STR_PARAM, &pubruri_caller_avp },
 	{"pubruri_callee_avp",  STR_PARAM, &pubruri_callee_avp },
+	{"db_url",              STR_PARAM, &db_url.s},
+	{"library_mode",        INT_PARAM, &library_mode},
 	{0, 0, 0 }
 };
 
@@ -130,8 +141,8 @@ struct module_exports exports= {
 	0,						/* extra processes */
 	mod_init,				/* module initialization function */
 	0,						/* response handling function */
-	0,						/* destroy function */
-	NULL					/* per-child init function */
+	mod_destroy,				/* destroy function */
+	child_init				/* per-child init function */
 };
 	
 
@@ -479,10 +490,12 @@ __dialog_created(struct dlg_cell *dlg, int type, struct dlg_cb_params *_params)
 static int mod_init(void)
 {
 	bind_pua_t bind_pua;
-
 	str s;
 	pv_spec_t avp_spec;
 	
+	if ( library_mode )
+		return 0;
+
 	bind_pua= (bind_pua_t)find_export("bind_pua", 1,0);
 	if (!bind_pua)
 	{
@@ -542,6 +555,15 @@ static int mod_init(void)
 
 	}
 
+	db_url.len = db_url.s ? strlen(db_url.s) : 0;
+	dialoginfo_db_table.len = dialoginfo_db_table.s ? strlen(dialoginfo_db_table.s) : 0;
+
+	/* binding to database module  */
+	if (db_url.len && db_bind_mod(&db_url, &pua_dialoginfo_dbf)) {
+		LM_ERR("Database module not found\n");
+		return -1;
+	}
+
 	return 0;
 }
 
@@ -572,3 +594,51 @@ void free_str_list_all(struct str_list * del_current) {
 	}
 
 }
+
+int bind_pua_dialoginfo(pua_dialoginfo_api_t* api)
+{
+	if (!api) {
+		LM_ERR("Invalid parameter value\n");
+		return -1;
+	}
+	
+	api->build_dialoginfo = build_dialoginfo;
+	return 0;
+}
+
+static int child_init(int rank)
+{
+	if ( library_mode )
+		return 0;
+	
+	if (rank==PROC_INIT || rank==PROC_MAIN || rank==PROC_TCP_MAIN)
+		return 0; /* do nothing for the main process */
+
+	if (pua_dialoginfo_dbf.init==0) {
+		LM_INFO("database not bound\n");
+		return 0;
+	}
+	/* In DB only mode do not pool the connections where possible. */
+	if ( (pua_dialoginfo_db = pua_dialoginfo_dbf.init(&db_url)) == NULL) {
+		LM_ERR("Child %d: connecting to database failed\n", rank);
+		return -1;
+	}
+	if (pua_dialoginfo_dbf.use_table(pua_dialoginfo_db, &dialoginfo_db_table) < 0) {
+		LM_ERR("child %d: Error in use_table pua\n", rank);
+		return -1;
+	}
+
+	LM_DBG("child %d: Database connection opened successfully\n", rank);
+
+	return 0;
+}
+
+
+static void mod_destroy(void)
+{
+	if ( library_mode )
+		return;
+	
+	if (pua_dialoginfo_db) 
+		pua_dialoginfo_dbf.close(pua_dialoginfo_db);
+}
diff --git a/modules/pua_dialoginfo/pua_dialoginfo.h b/modules/pua_dialoginfo/pua_dialoginfo.h
index f6e43b6..c2d002a 100644
--- a/modules/pua_dialoginfo/pua_dialoginfo.h
+++ b/modules/pua_dialoginfo/pua_dialoginfo.h
@@ -26,8 +26,12 @@
 #ifndef _PUA_DLGINFO_H
 #define _PUA_DLGINFO_H
 #include "../pua/pua_bind.h"
+#include "../../lib/srdb1/db.h"
 
 extern send_publish_t pua_send_publish;
+extern str dialoginfo_db_table;
+extern db1_con_t *pua_dialoginfo_db;
+extern db_func_t pua_dialoginfo_dbf;
 
 void dialog_publish_multi(char *state, struct str_list* ruris, str *entity, str *peer, str *callid,
 	unsigned int initiator, unsigned int lifetime, str *localtag, str *remotetag,
@@ -53,4 +57,7 @@ struct dlginfo_cell {
 void free_dlginfo_cell(void *param);
 void free_str_list_all(struct str_list * del_current);
 
+str* build_dialoginfo(char *state, str *entity, str *peer, str *callid, 
+	unsigned int initiator, str *localtag, str *remotetag,
+	str *localtarget, str *remotetarget, int version);
 #endif
diff --git a/modules/rls/rls.c b/modules/rls/rls.c
index 08dedcf..a5263d5 100644
--- a/modules/rls/rls.c
+++ b/modules/rls/rls.c
@@ -136,6 +136,7 @@ update_db_subs_t pres_update_db_subs_timer;
 extract_sdialog_info_t pres_extract_sdialog_info;
 int rls_events= EVENT_PRESENCE;
 int to_presence_code = 1;
+int rls_min_expires = 0;
 int rls_max_expires = 7200;
 int rls_reload_db_subs = 0;
 int rls_max_notify_body_len = 0;
@@ -238,6 +239,7 @@ static param_export_t params[]={
 	{ "notifier_processes",     INT_PARAM,   &rls_notifier_processes         },
 	{ "clean_period",           INT_PARAM,   &clean_period                   },
 	{ "rlpres_clean_period",    INT_PARAM,   &rlpres_clean_period            },
+	{ "min_expires",            INT_PARAM,   &rls_min_expires                },
 	{ "max_expires",            INT_PARAM,   &rls_max_expires                },
 	{ "hash_size",              INT_PARAM,   &hash_size                      },
 	{ "integrated_xcap_server", INT_PARAM,   &rls_integrated_xcap_server     },
diff --git a/modules/rls/rls.h b/modules/rls/rls.h
index a3b3c39..2557ab0 100644
--- a/modules/rls/rls.h
+++ b/modules/rls/rls.h
@@ -96,6 +96,7 @@ extern str rls_xcap_table;
 extern str db_url;
 extern int hash_size;
 extern shtable_t rls_table;
+extern int rls_min_expires;
 extern int rls_max_expires;
 extern int rls_integrated_xcap_server;
 extern int rls_events;
diff --git a/modules/rls/subscribe.c b/modules/rls/subscribe.c
index 5ebd739..89cdf6c 100644
--- a/modules/rls/subscribe.c
+++ b/modules/rls/subscribe.c
@@ -595,9 +595,10 @@ int rls_handle_subscribe(struct sip_msg* msg, str watcher_user, str watcher_doma
 	}
 
 	/* extract dialog information from message headers */
-	if(pres_extract_sdialog_info(&subs, msg, rls_max_expires,
-				&to_tag_gen, rls_server_address,
-				watcher_user, watcher_domain)<0)
+	if(pres_extract_sdialog_info(&subs, msg, rls_min_expires,
+                                rls_max_expires, &to_tag_gen,
+                                rls_server_address, watcher_user,
+                                watcher_domain)<0)
 	{
 		LM_ERR("bad subscribe request\n");
 		goto error;
diff --git a/modules/usrloc/dlist.c b/modules/usrloc/dlist.c
index 2f14f16..e4cc08e 100644
--- a/modules/usrloc/dlist.c
+++ b/modules/usrloc/dlist.c
@@ -629,6 +629,7 @@ int register_udomain(const char* _n, udomain_t** _d)
 	/* Test tables from database if we are gonna
 	 * to use database
 	 */
+#if 0
 	if (db_mode != NO_DB) {
 		con = ul_dbf.init(&db_url);
 		if (!con) {
@@ -648,7 +649,7 @@ int register_udomain(const char* _n, udomain_t** _d)
 
 		ul_dbf.close(con);
 	}
-
+#endif
 	d->next = root;
 	root = d;
 	
diff --git a/modules/usrloc/ul_mod.c b/modules/usrloc/ul_mod.c
index 77a2a40..af1ecd1 100644
--- a/modules/usrloc/ul_mod.c
+++ b/modules/usrloc/ul_mod.c
@@ -421,7 +421,8 @@ static int child_init(int _rank)
 		case WRITE_THROUGH:
 			/* we need connection from working SIP and TIMER and MAIN
 			 * processes only */
-			if (_rank<=0 && _rank!=PROC_TIMER && _rank!=PROC_MAIN)
+//			if (_rank<=0 && _rank!=PROC_TIMER && _rank!=PROC_MAIN)
+			if (_rank<=0 && _rank!=PROC_TIMER)
 				return 0;
 			break;
 		case WRITE_BACK:
@@ -437,6 +438,7 @@ static int child_init(int _rank)
 		LM_ERR("child(%d): failed to connect to database\n", _rank);
 		return -1;
 	}
+#if 0
 	/* _rank==PROC_SIPINIT is used even when fork is disabled */
 	if (_rank==PROC_SIPINIT && db_mode!= DB_ONLY) {
 		/* if cache is used, populate domains from DB */
@@ -449,6 +451,7 @@ static int child_init(int _rank)
 			uldb_preload_attrs(ptr->d);
 		}
 	}
+#endif
 
 	return 0;
 }
-- 
1.7.1

